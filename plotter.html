<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Text → Wiring Schematic (ASCII)</title>
  <style>
    :root{
      --bg:#0b0f14;
      --panel:#111826;
      --text:#e8eef7;
      --muted:#a7b2c4;
      --border:#233044;

      --ok:#45d483;     /* confirmed (.) */
      --warn:#ffb020;   /* unknown (?) */
      --bad:#ff4d4d;    /* mismatch (!) */
      --info:#7aa7ff;
    }
    html,body{height:100%;}
    body{
      margin:0;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      background:var(--bg);
      color:var(--text);
    }
    .wrap{
      max-width: 1100px;
      margin: 0 auto;
      padding: 12px;
      display: grid;
      gap: 8px;
    }
    .top{
      display:flex;
      gap:12px;
      align-items:flex-start;
      flex-wrap:wrap;
    }
    .card{
      background:var(--panel);
      border:1px solid var(--border);
      border-radius:12px;
      padding:8px;
      flex:1 1 420px;
      min-width:320px;
    }
    h1{
      font-size:16px;
      margin:0 0 6px 0;
      color:var(--text);
      letter-spacing:.2px;
    }
    p{
      margin:0 0 10px 0;
      color:var(--muted);
      font-size:12px;
      line-height:1.35;
    }
    textarea{
      width:100%;
      min-height: 200px;
      resize: vertical;
      box-sizing:border-box;
      background:#0b1220;
      color:var(--text);
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px;
      outline:none;
      font-size:13px;
      line-height:1.2;
      tab-size:2;
    }
    textarea:focus{border-color:#36507a;}
    .row{
      display:flex;
      gap:10px;
      flex-wrap:wrap;
      align-items:center;
      margin-top:10px;
    }
    button{
      background:#1a2a44;
      color:var(--text);
      border:1px solid #2a3c5c;
      border-radius:10px;
      padding:9px 12px;
      cursor:pointer;
      font-weight:600;
      font-size:13px;
    }
    button:hover{filter:brightness(1.1);}
    .pill{
      border:1px solid var(--border);
      background:#0b1220;
      border-radius:999px;
      padding:6px 10px;
      font-size:12px;
      color:var(--muted);
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    .legend span{display:inline-flex; gap:6px; align-items:center;}
    .dot{
      width:10px;height:10px;border-radius:50%;
      display:inline-block;
      border:1px solid rgba(255,255,255,.18);
    }
    .dot.ok{background:var(--ok);}
    .dot.warn{background:var(--warn);}
    .dot.bad{background:var(--bad);}

    pre{
      margin:0;
      white-space:pre;
      overflow:auto;
      background:#0b1220;
      border:1px solid var(--border);
      border-radius:10px;
      padding:8px;
      font-size:13px;
      line-height:0.9;
      letter-spacing:0;
      color:var(--text);
    }

    /* Colorize full lines in ASCII output */
    .out .ok{color:var(--ok); font-weight:700;}
    .out .warn{color:var(--warn); font-weight:700;}
    .out .bad{color:var(--bad); font-weight:700;}
    .out .info{color:var(--info); font-weight:700;}
    .muted{color:var(--muted);}
    .small{font-size:12px;}
    .hint{
      margin-top:10px;
      color:var(--muted);
      font-size:12px;
    }
  </style>
</head>
<body>
  <div class="wrap">
    <div class="top">
      <div class="card">
        <h1>Input</h1>
        <textarea id="input" spellcheck="false">1,AA,B01,.,1,AE,7
1,AA,B01,.,1,AE,9
1,AA,B01,.,1,AE,11
1,AE,11,.,1,AE,13</textarea>
        <div class="row">
          <button id="drawBtn">Draw schematic</button>
          <button id="loadExample">Load example</button>
          <div class="pill legend" aria-label="Legend">
            <span><i class="dot ok"></i> confirmed (.)</span>
            <span><i class="dot warn"></i> unknown (?)</span>
            <span><i class="dot bad"></i> mismatch (!)</span>
          </div>
        </div>
        <div class="hint">
          Tip: Each unique <span class="muted">FROM</span> becomes a “rung”. Multiple TOs from the same FROM branch downward.
        </div>
      </div>

      <div class="card">
        <h1>Output (ASCII schematic)</h1>
        <p class="small">This is plain text you can copy/paste into notes, tickets, or prompts.</p>
        <pre id="output" class="out"></pre>
      </div>
    </div>
  </div>

<script>
/**
 * Format:
 * [FROM PANEL],[FROM DEVICE],[FROM TERMINAL],[CONFIRMATION STATUS],[TO PANEL],[TO DEVICE],[TO TERMINAL]
 *
 * Status:
 * ?  not confirmed yet (orange)
 * !  does not lead back (red)
 * .  confirmed (green)
 */

const $ = (sel) => document.querySelector(sel);

const example = `# RUNG 1 — AA/B01 main trunk with multiple branches + sub-branches
1,AA,B01,.,1,AE,7
1,AA,B01,.,1,AE,9
1,AA,B01,.,1,AE,10
1,AA,B01,.,1,AE,11
1,AA,B01,.,1,AE,15
1,AA,B01,?,1,AE,17
1,AA,B01,!,1,AE,19

1,AE,7,.,7,D,D
7,D,D,.,7,D,E
7,D,E,.,7,D,F

1,AE,10,.,1,AA,B02
1,AA,B02,.,1,AF,1
1,AF,1,.,1,AF,3
1,AF,3,?,1,AF,5
1,AF,5,.,2,DD,1
2,DD,1,.,2,DD,3
2,DD,3,!,2,DD,5

1,AE,11,.,1,AE,13
1,AE,13,.,2,D,7
2,D,7,.,1,AA,C01
2,D,7,.,1,AA,C02
2,D,7,?,1,AA,C03
2,D,7,!,1,AA,C04
1,AA,C01,.,1,AA,C05
1,AA,C02,.,1,AA,C06
1,AA,C03,?,1,AA,C07
1,AA,C04,!,1,AA,C08

# RUNG 2 — AB/B02 simple spur with mixed status
1,AB,B02,.,1,AX,7
1,AB,B02,?,1,AX,9
1,AB,B02,!,1,AX,11
1,AX,7,.,1,AX,8
1,AX,8,.,1,AX,10
1,AX,10,?,2,AX,12
2,AX,12,.,2,AX,14
2,AX,14,!,2,AX,16

# RUNG 3 — AC/B03 with deeper tree and inline opportunities
1,AC,B03,.,1,AG,1
1,AC,B03,.,1,AG,3
1,AC,B03,.,1,AG,5
1,AG,1,.,1,AG,2
1,AG,2,.,1,AG,4
1,AG,4,.,3,G,1
3,G,1,.,3,G,2
3,G,2,?,3,G,3
3,G,3,.,3,G,4

1,AG,3,.,2,HH,10
2,HH,10,.,2,HH,11
2,HH,11,!,2,HH,12

1,AG,5,?,4,J,20
4,J,20,.,4,J,21
4,J,21,.,4,J,22
4,J,22,!,4,J,23

# RUNG 4 — AD/B04 “bus” style fanout then recombine
1,AD,B04,.,1,AH,1
1,AD,B04,.,1,AH,2
1,AD,B04,.,1,AH,3
1,AH,1,.,2,KK,1
1,AH,2,?,2,KK,2
1,AH,3,!,2,KK,3
2,KK,1,.,2,KK,10
2,KK,2,.,2,KK,10
2,KK,3,.,2,KK,10
2,KK,10,.,2,KK,11
2,KK,11,.,2,KK,12

# RUNG 5 — BA/TB01 terminal block ladder
2,BA,TB01,.,2,BA,TB02
2,BA,TB02,.,2,BA,TB03
2,BA,TB03,.,2,BA,TB04
2,BA,TB04,?,2,BA,TB05
2,BA,TB05,.,2,BA,TB06
2,BA,TB06,!,2,BA,TB07
2,BA,TB07,.,2,BA,TB08
2,BA,TB08,.,2,BA,TB09
2,BA,TB09,.,2,BA,TB10

# RUNG 6 — CB/X01 with nested branches and long terminals (to test centering)
3,CB,X01,.,3,CB,TERM-1
3,CB,X01,.,3,CB,TERM-12
3,CB,X01,.,3,CB,TERM-123
3,CB,TERM-1,.,5,Z,1
3,CB,TERM-12,?,5,Z,2
3,CB,TERM-123,!,5,Z,3
5,Z,1,.,5,Z,10
5,Z,2,.,5,Z,11
5,Z,3,.,5,Z,12
5,Z,10,.,5,Z,20
5,Z,11,?,5,Z,21
5,Z,12,!,5,Z,22

# RUNG 7 — “loop-back” / reciprocity testing (mismatch candidates)
4,DA,P1,.,4,DA,P2
4,DA,P2,.,4,DA,P3
4,DA,P3,?,4,DA,P4
4,DA,P4,!,4,DA,P1

# RUNG 8 — Multi-root same panel different devices
1,AA,B10,.,1,AE,21
1,AA,B10,.,1,AE,22
1,AA,B10,?,1,AE,23
1,AE,21,.,2,D,10
1,AE,22,.,2,D,11
1,AE,23,!,2,D,12
2,D,10,.,1,AA,C10
2,D,11,?,1,AA,C11
2,D,12,!,1,AA,C12

# RUNG 9 — Another clean chain with inline segments
6,EF,100,.,6,EF,101
6,EF,101,.,6,EF,102
6,EF,102,.,6,EF,103
6,EF,103,?,6,EF,104
6,EF,104,.,6,EF,105
6,EF,105,!,6,EF,106

# RUNG 10 — Mixed fanout + multiple nested levels
7,FG,OUT1,.,7,FG,IN1
7,FG,OUT1,.,7,FG,IN2
7,FG,OUT1,.,7,FG,IN3
7,FG,IN1,.,7,FG,BR1
7,FG,BR1,.,8,HH,1
8,HH,1,.,8,HH,2
8,HH,2,.,8,HH,3

7,FG,IN2,?,7,FG,BR2
7,FG,BR2,?,8,HH,10
8,HH,10,?,8,HH,11
8,HH,11,!,8,HH,12

7,FG,IN3,!,7,FG,BR3
7,FG,BR3,!,8,HH,20
8,HH,20,.,8,HH,21
8,HH,21,.,8,HH,22

# RUNG 11 — Short “status propagation” test
9,JJ,A1,.,9,JJ,A2
9,JJ,A1,?,9,JJ,A3
9,JJ,A1,!,9,JJ,A4

# RUNG 12 — Lots of siblings to test backbone continuity
10,KK,ROOT,.,10,KK,N1
10,KK,ROOT,.,10,KK,N2
10,KK,ROOT,.,10,KK,N3
10,KK,ROOT,.,10,KK,N4
10,KK,ROOT,?,10,KK,N5
10,KK,ROOT,!,10,KK,N6
10,KK,N1,.,11,LL,1
10,KK,N2,.,11,LL,2
10,KK,N3,.,11,LL,3
10,KK,N4,.,11,LL,4
10,KK,N5,?,11,LL,5
10,KK,N6,!,11,LL,6
11,LL,1,.,11,LL,10
11,LL,2,.,11,LL,11
11,LL,3,.,11,LL,12
11,LL,4,.,11,LL,13
11,LL,5,?,11,LL,14
11,LL,6,!,11,LL,15`;

function escapeHtml(str){
  return str
    .replaceAll("&","&amp;")
    .replaceAll("<","&lt;")
    .replaceAll(">","&gt;")
    .replaceAll('"',"&quot;")
    .replaceAll("'","&#039;");
}

function normalizeCell(s){
  return (s ?? "").trim();
}

function parseLines(text){
  const lines = text.split(/\r?\n/).map(l => l.trim()).filter(l => l && !l.startsWith("#"));
  const rows = [];
  const errors = [];

  for (let i=0;i<lines.length;i++){
    const raw = lines[i];
    const parts = raw.split(",").map(normalizeCell);

    if (parts.length !== 7){
      errors.push({line:i+1, msg:`Expected 7 comma-separated values, got ${parts.length}`, raw});
      continue;
    }

    const [fp, fd, ft, st, tp, td, tt] = parts;

    const status = st || "?";
    if (!["?","!","."].includes(status)){
      errors.push({line:i+1, msg:`Invalid status "${status}" (use ?, !, or .)`, raw});
      continue;
    }

    rows.push({
      from:{panel:fp, device:fd, term:ft},
      to:{panel:tp, device:td, term:tt},
      status
    });
  }

  return {rows, errors};
}

function keyOf(endpoint){
  return `${endpoint.panel}|${endpoint.device}|${endpoint.term}`;
}

function labelOf(endpoint){
  // Example label: 1/AA/B01
  return `${endpoint.panel}/${endpoint.device}/${endpoint.term}`;
}

function lineClass(status){
  if (status === ".") return "ok";
  if (status === "?") return "warn";
  return "bad";
}

// Combine two statuses into the "worst" one for coloring purposes.
// Order: . (best) < ? < ! (worst)
function combineStatus(a, b){
  const rank = (s) => (s === "!" ? 2 : (s === "?" ? 1 : 0));
  return rank(a) >= rank(b) ? a : b;
}

function buildSchematic(rows, errors){
  if ((!rows || rows.length === 0) && errors.length === 0){
    return `<span class="muted">Paste wiring lines on the left, then click "Draw schematic".</span>`;
  }

  // Build graph structure: map FROM endpoint to array of connections
  const graph = new Map();
  const toEndpoints = new Set();
  
  for (const r of rows){
    const fromKey = keyOf(r.from);
    if (!graph.has(fromKey)){
      graph.set(fromKey, {endpoint: r.from, conns: []});
    }
    graph.get(fromKey).conns.push(r);
    
    // Track all TO endpoints to identify roots
    toEndpoints.add(keyOf(r.to));
  }

  // Sort connections by TO label for consistent output
  for (const node of graph.values()){
    node.conns.sort((a,b) => {
      const la = labelOf(a.to);
      const lb = labelOf(b.to);
      return la.localeCompare(lb, undefined, {numeric:true});
    });
  }

  // Find root nodes: endpoints that are FROM but never TO
  const roots = Array.from(graph.keys())
    .filter(k => !toEndpoints.has(k))
    .map(k => graph.get(k))
    .sort((a,b) => {
      return labelOf(a.endpoint).localeCompare(labelOf(b.endpoint), undefined, {numeric:true});
    });

  let out = "";

  // Errors section
  if (errors.length){
    out += `<span class="bad">Input issues:</span>\n`;
    for (const e of errors){
      out += `  <span class="bad">Line ${e.line}:</span> ${escapeHtml(e.msg)}\n`;
      out += `    <span class="muted">${escapeHtml(e.raw)}</span>\n`;
    }
    out += "\n";
  }


  // Recursive function to draw a node in vertical condensed style
  // "spines" is a list of ancestor vertical columns that must remain visible while we render this subtree.
  // Each spine is { col: number, status: "?"|"!"|"." } where col is a character column index.
  function drawNode(nodeKey, baseIndent, isRoot, parentStatus, spines){
    const node = graph.get(nodeKey);
    if (!node) return;

    const nodeLabel = labelOf(node.endpoint);
    const conns = node.conns || [];
    if (conns.length === 0) return;

    // Helpers: render a line where ancestor spines keep their OWN color (do not inherit the child's status)
    function emitLine(rawLine, cssClass, spineList){
      const sp = (spineList || []).filter(s => s && Number.isFinite(s.col) && s.col >= 0);
      const maxCol = sp.length ? Math.max(...sp.map(s => s.col)) : -1;

      // pad line so we can place spine characters
      const chars = Array.from(rawLine);
      if (chars.length <= maxCol){
        chars.push(...new Array(maxCol - chars.length + 1).fill(" "));
      }

      // class per character (default = this line's class)
      const clsPer = new Array(chars.length).fill(cssClass);

      // place spines (only if that column is blank) and give them their own class
      for (const s of sp){
        const col = s.col;
        // Only overlay a spine into *blank* space.
        // If this line already has a character at that column (e.g., the line's
        // own backbone/branch), don't let an ancestor spine recolor it.
        if (chars[col] === " "){
          chars[col] = "│";
          clsPer[col] = lineClass(s.status || ".");
        }
      }

      // emit as minimal spans (group runs by class)
      let html = "";
      let runClass = clsPer[0] || cssClass;
      let runText = chars[0] ?? "";
      for (let i=1;i<chars.length;i++){
        const c = chars[i];
        const cl = clsPer[i] || cssClass;
        if (cl === runClass){
          runText += c;
        } else {
          html += `<span class="${runClass}">${escapeHtml(runText)}</span>`;
          runClass = cl;
          runText = c;
        }
      }
      html += `<span class="${runClass}">${escapeHtml(runText)}</span>`;
      out += html + "\n";
    }

    // Calculate indent to center branch character on terminal
    let indent;
    if (isRoot){
      // Center the branch character on the terminal part of the label
      const lastSlash = nodeLabel.lastIndexOf("/");
      const terminal = lastSlash >= 0 ? nodeLabel.substring(lastSlash + 1) : nodeLabel;
      const terminalStart = lastSlash + 1;
      const terminalCenter = terminalStart + Math.floor(terminal.length / 2);
      indent = " ".repeat(Math.max(0, terminalCenter - 1));
    } else {
      indent = baseIndent;
    }

    const myCol = indent.length;

    // Root label
    if (isRoot){
      out += `<span class="info">${escapeHtml(nodeLabel)}</span>\n`;
      // Show the backbone starting under the root label
      const firstStatus = conns[0]?.status ?? ".";
      emitLine(`${indent}│`, lineClass(firstStatus), spines);
    }

    conns.forEach((r, i) => {
      const toKey = keyOf(r.to);
      const toLabel = labelOf(r.to);
      const toHasChildren = graph.has(toKey);
      const isLastConn = i === conns.length - 1;

      const branchChar = isLastConn ? "└" : "├";

      // If this connection is not the last sibling, keep THIS node's spine visible throughout the child's subtree.
      const childSpines = (spines ? [...spines] : []);

      // Choose effective status (propagate parent status if needed)
      const effectiveStatus =
        (r.status === "!" || r.status === "?")
          ? r.status
          : (r.status === "." && parentStatus ? parentStatus : r.status);

      // If this connection is not the last sibling, keep THIS node's spine visible throughout the child's subtree.
      // IMPORTANT: store the spine's OWN status so its color doesn't get overwritten by deeper children.
      if (!isLastConn){
        childSpines.push({col: myCol, status: effectiveStatus});
      }

      const cls = lineClass(effectiveStatus);

      // Inline optimization (single child)
      const toNode = toHasChildren ? graph.get(toKey) : null;
      const hasSingleChild = toHasChildren && toNode.conns.length === 1;

      if (hasSingleChild){
        const childConn = toNode.conns[0];
        const childLabel = labelOf(childConn.to);
        // If we collapse a single-child chain onto one line, color it using the "worst" status
        // between the parent link and the child link so a ?/! in either one is visible.
        const childEff =
          (childConn.status === "!" || childConn.status === "?")
            ? childConn.status
            : (childConn.status === "." && effectiveStatus ? effectiveStatus : childConn.status);
        const combined = combineStatus(effectiveStatus, childEff);
        const combinedCls = lineClass(combined);
        emitLine(`${indent}${branchChar}── ${toLabel} ── ${childLabel}`, combinedCls, spines);

        const childKey = keyOf(childConn.to);
        const hasNestedGrandchildren = graph.has(childKey);
        if (hasNestedGrandchildren){
          // compute nested indent centered on child's terminal as before
          const branchPrefixLength = 4; // "├── " = 4
          const childLastSlash = childLabel.lastIndexOf("/");
          const childTerminal = childLastSlash >= 0 ? childLabel.substring(childLastSlash + 1) : childLabel;
          const childTerminalStartInLabel = childLastSlash + 1;
          const childTerminalStartInLine = indent.length + branchPrefixLength + toLabel.length + 1 + 4 + childTerminalStartInLabel;
          const childTerminalCenterInLine = childTerminalStartInLine + Math.floor(childTerminal.length / 2);
          const nestedIndent = " ".repeat(Math.max(0, childTerminalCenterInLine - 1));

          emitLine(`${nestedIndent}│`, combinedCls, childSpines);
          drawNode(childKey, nestedIndent, false, combined, childSpines);
        }

        // Between siblings at THIS level, show the backbone connector
        if (!isLastConn){
          emitLine(`${indent}│`, combinedCls, spines);
        }
        return;
      }

      // Normal branch
      emitLine(`${indent}${branchChar}── ${toLabel}`, cls, spines);

      if (toHasChildren){
        // compute nested indent centered on TO terminal
        const branchPrefixLength = 4; // "├── " = 4
        const toLastSlash = toLabel.lastIndexOf("/");
        const toTerminal = toLastSlash >= 0 ? toLabel.substring(toLastSlash + 1) : toLabel;
        const toTerminalStartInLabel = toLastSlash + 1;
        const toTerminalStartInLine = indent.length + branchPrefixLength + toTerminalStartInLabel;
        const toTerminalCenterInLine = toTerminalStartInLine + Math.floor(toTerminal.length / 2);
        const nestedIndent = " ".repeat(Math.max(0, toTerminalCenterInLine - 1));

        emitLine(`${nestedIndent}│`, cls, childSpines);
        drawNode(toKey, nestedIndent, false, effectiveStatus, childSpines);

        if (!isLastConn){
          emitLine(`${indent}│`, cls, spines);
        }
      } else if (!isLastConn){
        emitLine(`${indent}│`, cls, spines);
      }
    });
  }

  // Draw each root tree
  roots.forEach((root, rootIdx) => {
    const rootKey = keyOf(root.endpoint);
    drawNode(rootKey, "", true, null, []);
    if (rootIdx < roots.length - 1){
      out += "\n";
    }
  });

  out += `\n<span class="muted">Total rungs:</span> ${roots.length}   <span class="muted">Total wires:</span> ${rows.length}\n`;
  return out;
}

function draw(){
  const {rows, errors} = parseLines($("#input").value);
  $("#output").innerHTML = buildSchematic(rows, errors);
}

$("#drawBtn").addEventListener("click", draw);
$("#loadExample").addEventListener("click", () => {
  $("#input").value = example;
  draw();
});

// Auto-render once on load
draw();
</script>
</body>
</html>