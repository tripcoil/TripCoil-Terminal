<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TripCoil Terminal V1.1</title>
  <style>
    :root {
      --bg: #05080a;
      --fg: #b8ffe1;
      --dim: #67d7b3;
      --accent: #19ff9a;
      --warn: #ffd36a;
      --shadow: rgba(25, 255, 154, .20);
      --scan: rgba(25, 255, 154, .06);
      --border: rgba(25, 255, 154, .20);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 30% 20%, #071115 0%, var(--bg) 55%, #030506 100%);
      overflow: hidden;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    .frame {
      width: min(980px, 92vw);
      height: min(620px, 86vh);
      border-radius: 18px;
      border: 1px solid var(--border);
      box-shadow: 0 0 40px var(--shadow);
      overflow: hidden;
      position: relative;
      background: #000;
    }

    .titlebar {
      height: 44px;
      display: flex;
      align-items: center;
      padding: 0 14px;
      background: rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid var(--border);
    }

    .title {
      color: var(--fg);
      font-size: 13px;
      opacity: 0.8;
    }

    .header.green {
      color: #28c840;
      font-weight: bold;
    }

    .header.red {
      color: #ff5f57;
      font-weight: bold;
    }

    .terminal {
      position: absolute;
      inset: 44px 0 0 0;
      padding: 20px;
      color: var(--fg);
      overflow-y: auto;
    }

    .prompt {
      color: var(--accent);
    }

    .input-row {
      display: flex;
      align-items: baseline;
      gap: 10px;
      padding: 2px 0;
    }

    .input-group {
      display: inline-flex;
      gap: 0;
    }

    .caret {
      display: inline-block;
      width: 9px;
      height: 1.1em;
      background: var(--accent);
      animation: blink 1s infinite;
      vertical-align: middle;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    /* Fix for Safari/Brave focus */
    .ghost-input {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
      opacity: 0;
      border: none;
      pointer-events: none;
      z-index: -1;
    }

    .notepad-overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: #fff;
      z-index: 100;
      flex-direction: column;
      color: #000;
    }

    .notepad-header {
      height: 32px;
      background: #eee;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-family: sans-serif;
      font-size: 12px;
    }

    .notepad-close {
      margin-left: auto;
      width: 45px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .notepad-close:hover {
      background: #e81123;
      color: #fff;
    }

    .notepad-content {
      flex: 1;
      padding: 15px;
      font-family: 'Consolas', monospace;
      font-size: 14px;
      border: none;
      outline: none;
      resize: none;
    }

    .edit-menu {
      display: flex;
      gap: 8px;
      margin-left: 15px;
    }

    .cmd-btn {
      background: #e0e0e0;
      border: 1px solid #b0b0b0;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      font-family: sans-serif;
      color: #333;
    }

    .cmd-btn:hover {
      background: #d0d0d0;
      border-color: #999;
    }

    .cmd-btn:active {
      background: #ccc;
    }

    /* Mobile Controls */
    .mobile-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
      opacity: 0.6;
    }

    .mobile-controls:hover {
      opacity: 1;
    }

    .history-btn {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--accent);
      color: var(--accent);
      font-size: 20px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      backdrop-filter: blur(2px);
    }

    .history-btn:active {
      background: var(--accent);
      color: #000;
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="titlebar">
      <div class="title" id="main-header">TRIPCOIL TERMINAL V1.1</div>
    </div>
    <div class="terminal" id="terminal">
      <div id="content"></div>
      <input class="ghost-input" id="ghost" type="text" autocomplete="off" spellcheck="false" autofocus>
    </div>

    <div class="notepad-overlay" id="notepad-overlay">
      <div class="notepad-header">
        <span>TC-Export.txt - Notepad</span>
        <div class="edit-menu">
          <button class="cmd-btn" id="btn-copy">COPY</button>
          <button class="cmd-btn" id="btn-paste">PASTE</button>
        </div>
        <div class="notepad-close" onclick="closeNotepad()">✕</div>
      </div>
      <textarea class="notepad-content" id="notepad-textarea"></textarea>
    </div>

    <div class="mobile-controls">
      <div class="history-btn" id="btn-up">∧</div>
      <div class="history-btn" id="btn-down">∨</div>
    </div>
  </div>

  <script>
    const content = document.getElementById('content');
    const terminal = document.getElementById('terminal');
    const ghost = document.getElementById('ghost');
    const overlay = document.getElementById('notepad-overlay');
    const textArea = document.getElementById('notepad-textarea');
    const btnCopy = document.getElementById('btn-copy');
    const btnPaste = document.getElementById('btn-paste');
    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');
    const mainHeader = document.getElementById('main-header'); // Cached ref

    // --- STATE MANAGEMENT ---
    const STATE_MENU = 'MENU';
    const STATE_TRACE = 'TRACE';
    let currentState = STATE_MENU;

    // --- SHARED UTILS ---
    let inputBuffer = '';

    // History
    const commandHistory = [];
    let historyIndex = -1;
    let tempInputBuffer = '';

    function setHeader(text, type = 'normal') {
      mainHeader.textContent = text;
      mainHeader.className = 'title'; // Reset
      if (type === 'green') mainHeader.className += ' header green';
      if (type === 'red') mainHeader.className += ' header red';
    }

    function clearTerminal() {
      content.innerHTML = '';
      inputBuffer = '';
    }

    function appendLine(html) {
      const div = document.createElement('div');
      div.className = 'term-line'; // Class for easier removal
      div.innerHTML = html;
      content.appendChild(div);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function removeLastLine() {
      const lines = content.getElementsByClassName('term-line');
      if (lines.length > 0) {
        lines[lines.length - 1].remove();
      }
    }

    function renderInput(prompt) {
      let active = document.getElementById('active-row');
      if (active) active.remove();

      const row = document.createElement('div');
      row.id = 'active-row';
      row.className = 'input-row';
      // Using the robust .input-group fix
      row.innerHTML = `<span class="prompt">${prompt}</span> <span class="input-group"><span>${inputBuffer}</span><span class="caret"></span></span>`;
      content.appendChild(row);
      terminal.scrollTop = terminal.scrollHeight;
    }

    // --- HISTORY LOGIC ---
    function navigateHistory(direction) {
      if (commandHistory.length === 0) return;

      if (historyIndex === -1 && direction === -1) {
        tempInputBuffer = inputBuffer;
        historyIndex = commandHistory.length - 1;
      } else {
        historyIndex += direction;
      }

      if (historyIndex < -1) historyIndex = -1;
      if (historyIndex >= commandHistory.length) historyIndex = commandHistory.length - 1;

      if (historyIndex === -1) {
        inputBuffer = tempInputBuffer;
      } else {
        inputBuffer = commandHistory[historyIndex];
      }
      refreshUI();
    }

    // --- MOBILE BUTTONS ---
    if (btnUp && btnDown) {
      btnUp.addEventListener('click', (e) => {
        e.stopPropagation();
        // Undo Action
        if (currentState === STATE_TRACE) {
          TraceTool.undo();
        } else {
          navigateHistory(-1); // Menu context
        }
        focus();
      });
      btnDown.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentState === STATE_MENU) navigateHistory(1);
        focus();
      });
    }

    // --- MAIN MENU PROGRAM ---
    const MenuTool = {
      init() {
        clearTerminal();
        setHeader('TRIPCOIL TERMINAL V1.1');
        appendLine('<span class="prompt">AVAILABLE PROGRAMS:</span>');
        appendLine('&nbsp;&nbsp;1. TRACE TOOL');
        appendLine('<br>'); // spacer
        inputBuffer = '';
        this.render();
      },
      handleInput(val) { // val is fully committed string OR we handle keystrokes? 
        // Architecture decision: handle key logic globally, pass committed string here?
        // Let's stick to global buffer, this handles the ACTION.
        if (val === '1' || val === 'TRACE TOOL' || val === 'TRACE') {
          switchState(STATE_TRACE);
        } else {
          appendLine(`<span class="prompt">SELECT PROGRAM></span> <span>${val}</span>`);
          appendLine(`<span style="color:var(--warn)">INVALID SELECTION</span>`);
        }
      },
      render() {
        renderInput('SELECT PROGRAM>');
      }
    };

    // --- TRACE TOOL PROGRAM (LOOP-BACK & BRANCH) ---
    const TraceTool = {
      // State
      discoveryStack: [], // Renamed from stack
      history: [],
      inputs: {},
      phase: 'SEED',
      currentFrom: null,
      undoStack: [], // Snapshots

      // Constants
      PHASE: {
        SEED_PANEL: 'SEED_PANEL',
        SEED_DEVICE: 'SEED_DEVICE',
        SEED_TERMINAL: 'SEED_TERMINAL',

        DEST_PANEL: 'DEST_PANEL',
        DEST_DEVICE: 'DEST_DEVICE',
        DEST_TERMINAL: 'DEST_TERMINAL',

        CALLBACK: 'CALLBACK',
        DENSITY: 'DENSITY',

        COMPLETE: 'COMPLETE'
      },

      init() {
        clearTerminal();
        setHeader('TRACE TOOL - LOOP-BACK BRANCH MODE');
        this.discoveryStack = [];
        this.history = [];
        this.undoStack = [];
        this.inputs = {};
        this.currentFrom = null;
        this.phase = this.PHASE.SEED_PANEL;
        inputBuffer = '';
        this.render();
      },

      saveState(processedInput) {
        // Serialize current state
        const snapshot = {
          phase: this.phase,
          inputs: JSON.parse(JSON.stringify(this.inputs)),
          discoveryStack: JSON.parse(JSON.stringify(this.discoveryStack)),
          history: JSON.parse(JSON.stringify(this.history)),
          currentFrom: this.currentFrom ? JSON.parse(JSON.stringify(this.currentFrom)) : null,
          lastInput: processedInput
        };
        this.undoStack.push(snapshot);
      },

      undo() {
        if (this.undoStack.length === 0) return;

        const snap = this.undoStack.pop();

        // Restore
        this.phase = snap.phase;
        this.inputs = snap.inputs;
        this.discoveryStack = snap.discoveryStack;
        this.history = snap.history;
        this.currentFrom = snap.currentFrom;

        // Visual: Remove last line
        removeLastLine();

        // Input: Restore what they typed
        inputBuffer = snap.lastInput;

        this.render();
      },

      handleInput(val) {
        this.saveState(val); // Undo point -> Current State + The Input being processed

        const P = this.PHASE;

        switch (this.phase) {
          // --- SEED PHASE ---
          case P.SEED_PANEL:
            this.inputs.p = val;
            appendLine(`<span class="prompt">FROM PANEL:</span> <span>${val}</span>`);
            this.phase = P.SEED_DEVICE;
            break;

          case P.SEED_DEVICE:
            this.inputs.d = val;
            appendLine(`<span class="prompt">FROM DEVICE:</span> <span>${val}</span>`);
            this.phase = P.SEED_TERMINAL;
            break;

          case P.SEED_TERMINAL:
            this.inputs.t = val;
            appendLine(`<span class="prompt">FROM TERMINAL:</span> <span>${val}</span>`);
            // Seed established. Initialize currentFrom.
            this.currentFrom = { p: this.inputs.p, d: this.inputs.d, t: this.inputs.t, count: 0 };
            this.startDestinationPhase();
            break;

          // --- DESTINATION PHASE ---
          case P.DEST_PANEL:
            this.inputs.toP = val;
            appendLine(`<span class="prompt">TO PANEL:</span> <span>${val}</span>`);
            this.phase = P.DEST_DEVICE;
            break;

          case P.DEST_DEVICE:
            this.inputs.toD = val;
            appendLine(`<span class="prompt">TO DEVICE:</span> <span>${val}</span>`);
            this.phase = P.DEST_TERMINAL;
            break;

          case P.DEST_TERMINAL:
            this.inputs.toT = val;
            appendLine(`<span class="prompt">TO TERMINAL:</span> <span>${val}</span>`);
            this.phase = P.CALLBACK;
            break;

          // --- CALLBACK PHASE ---
          case P.CALLBACK:
            const norm = val.toUpperCase().trim();
            const isYes = norm.startsWith('Y');
            this.inputs.callsBack = isYes ? 'Y' : 'N';

            appendLine(`<span class="prompt">CALLS BACK TO ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}?</span> <span>${this.inputs.callsBack}</span>`);

            // Update Header Color
            const hdrText = `(PANEL ${this.inputs.toP}) ${this.inputs.toD}/${this.inputs.toT}`;
            setHeader(hdrText, isYes ? 'green' : 'red');

            this.phase = P.DENSITY;
            break;

          // --- DENSITY PHASE ---
          case P.DENSITY:
            const count = parseInt(val);
            if (isNaN(count)) {
              appendLine(`<span style="color:var(--warn)">INVALID NUMBER</span>`);
              this.render();
              return;
            }
            appendLine(`<span class="prompt">BESIDES ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}, HOW MANY WIRES ON ${this.inputs.toP}/${this.inputs.toD}/${this.inputs.toT}?</span> <span>${val}</span>`);
            this.processJump(count);
            break;
        }

        this.render();
      },

      startDestinationPhase() {
        this.inputs.toP = '';
        this.inputs.toD = '';
        this.inputs.toT = ''; // Clear destination buffer
        this.inputs.callsBack = '';
        this.phase = this.PHASE.DEST_PANEL;
      },

      markHistoryComplete(term) {
        // Update any history records where this terminal was the destination
        this.history.forEach(h => {
          if (h.to.p === term.p && h.to.d === term.d && h.to.t === term.t) {
            h.status = 'C';
          }
        });
      },

      processJump(toCount) {
        // 1. Determine Status (Column 12)
        const status = toCount > 0 ? `${toCount}?` : 'C';

        // 2. Record WIR Row
        // Mapping: From(2,3,4) -> To(8,9,10) ... Status(12)
        this.history.push({
          from: { p: this.currentFrom.p, d: this.currentFrom.d, t: this.currentFrom.t },
          to: { p: this.inputs.toP, d: this.inputs.toD, t: this.inputs.toT },
          callsBack: this.inputs.callsBack,
          status: status
        });

        appendLine(`<div style="color:var(--dim)">> TRACED: ${this.currentFrom.t} -> ${this.inputs.toT} [${status}]</div>`);

        // 3. Update Discovery Stack (The Countdown)
        // If currentFrom is in discoveryStack, decrement it.
        // We need to find the specific reference in the discoveryStack.
        const stackIdx = this.discoveryStack.findIndex(n =>
          n.p === this.currentFrom.p && n.d === this.currentFrom.d && n.t === this.currentFrom.t
        );

        if (stackIdx !== -1) {
          this.discoveryStack[stackIdx].count--;
          if (this.discoveryStack[stackIdx].count <= 0) {
            this.markHistoryComplete(this.discoveryStack[stackIdx]);
            this.discoveryStack.splice(stackIdx, 1); // Remove completed
            // appendLine(`<div style="color:var(--dim)">> ${this.currentFrom.t} COMPLETED</div>`);
          } else {
            // appendLine(`<div style="color:var(--dim)">> ${this.currentFrom.t} PENDING (${this.discoveryStack[stackIdx].count})</div>`);
          }
        }

        // 4. Handle "To" Terminal
        const toNode = {
          p: this.inputs.toP,
          d: this.inputs.toD,
          t: this.inputs.toT,
          count: toCount
        };

        if (toCount > 0) {
          // Push To Node to Discovery Stack (Step E)
          this.discoveryStack.push(toNode);

          // Move forward: To becomes From
          this.currentFrom = toNode;
          this.startDestinationPhase();
        } else {
          // Dead End (Step F)
          // Circle Back
          this.circleBack();
        }
      },

      circleBack() {
        if (this.discoveryStack.length > 0) {
          // Pull most recent from Active Discovery Stack
          const nextSrc = this.discoveryStack[this.discoveryStack.length - 1]; // Peek/Get
          this.currentFrom = nextSrc;

          appendLine(`<div style="color:var(--accent)">↺ CIRCLING BACK TO: ${nextSrc.p} / ${nextSrc.d} / ${nextSrc.t} (${nextSrc.count} LEFT)</div>`);

          this.startDestinationPhase();
        } else {
          // Session Complete
          this.phase = this.PHASE.COMPLETE;
          setHeader('SESSION COMPLETE', 'green');
          appendLine('<div style="color:var(--warn)">NO PENDING WIRES - TRACE COMPLETE</div>');
          appendLine('<div class="prompt">TYPE "EXPORT" TO SAVE CSV</div>');
        }
      },

      render() {
        let label = '';
        const P = this.PHASE;

        switch (this.phase) {
          case P.SEED_PANEL: label = 'FROM PANEL?'; break;
          case P.SEED_DEVICE: label = 'FROM DEVICE?'; break;
          case P.SEED_TERMINAL: label = 'FROM TERMINAL?'; break;

          case P.DEST_PANEL:
            label = `[FROM ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}] TO PANEL?`; // Contextual prompt
            break;
          case P.DEST_DEVICE: label = 'TO DEVICE?'; break;
          case P.DEST_TERMINAL: label = 'TO TERMINAL?'; break;

          case P.CALLBACK:
            label = `CALLS BACK TO ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}? (Y/N)`;
            break;

          case P.DENSITY:
            label = `BESIDES ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}, HOW MANY WIRES ON ${this.inputs.toP}/${this.inputs.toD}/${this.inputs.toT}?`;
            break;

          case P.COMPLETE: label = 'COMPLETE (TYPE QUIT)'; break;
        }

        if (label) renderInput(label);
      }
    };

    // --- GLOBAL HANDLERS ---

    function switchState(newState) {
      currentState = newState;
      if (newState === STATE_MENU) MenuTool.init();
      if (newState === STATE_TRACE) TraceTool.init();
    }

    function openNotepad() {
      // Generate CSV from History
      let content = '';

      if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
        // CSV Mapping:
        // 2,3,4 = From P,D,T
        // 8,9,10 = To P,D,T
        // 12 = Status
        // Note: Header color (callsBack) logic not explicitly mapped to a specific CSV column in 'Specification' table 
        // EXCEPT "Header Color (Green = Y, Red = N)". Usually this assumes user manually handles it or it's logic.
        // Wait, "Step A... Step F...". CSV Mapping table in prompt:
        // A -> Cols 2,3,4. B -> Cols 8,9,10. D -> Col 12.
        // It doesn't map 'Calls Back' to a column, just visual Header Color.
        // Original code mapped it to near end. 
        // Let's stick to the prompt's explicit mapping.

        content = TraceTool.history.map(h => {
          // WIR, FromP, FromD, FromT, , , , ToP, ToD, ToT, , Status, ,
          //     2      3      4       5 6 7  8    9    10   11 12
          return `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${h.status},,`;
        }).join('\n');
      }

      if (content) textArea.value = content;

      overlay.style.display = 'flex';
      overlay.querySelector('.notepad-header span').textContent = 'Notepad';
    }

    function closeNotepad() {
      overlay.style.display = 'none';
      focus();
    }

    // Make global for onclick
    window.closeNotepad = closeNotepad;

    // --- EVENT LOOP ---
    const focus = () => ghost.focus();
    window.addEventListener('click', focus);

    window.addEventListener('keydown', (e) => {
      if (overlay.style.display === 'flex') return; // Typing in notepad handled natively
      focus();

      if (e.key === 'Enter') {
        const rawCmd = inputBuffer.trim();
        const cmd = rawCmd.toUpperCase();

        // Push to History
        if (rawCmd) {
          commandHistory.push(rawCmd);
          historyIndex = -1;
          tempInputBuffer = '';
        }

        // Global Commands
        if (cmd === 'QUIT') {
          inputBuffer = '';
          switchState(STATE_MENU);
          return;
        }
        if (cmd === 'EXPORT' || cmd === 'TEXT' || cmd === 'CSV') {
          inputBuffer = '';
          openNotepad();
          if (currentState === STATE_MENU) MenuTool.render();
          if (currentState === STATE_TRACE) TraceTool.render();
          return;
        }

        // Route to Tool
        inputBuffer = '';
        if (currentState === STATE_MENU) {
          MenuTool.handleInput(cmd);
        } else if (currentState === STATE_TRACE) {
          TraceTool.handleInput(cmd);
        }

      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (currentState === STATE_TRACE) {
          TraceTool.undo();
        } else {
          navigateHistory(-1);
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        // Down behavior undefined so left as history or no-op
        if (currentState === STATE_MENU) navigateHistory(1);
      } else if (e.key === 'Backspace') {
        inputBuffer = inputBuffer.slice(0, -1);
        refreshUI();
      } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        inputBuffer += e.key.toUpperCase();
        refreshUI();
      }
    });

    function refreshUI() {
      if (currentState === STATE_MENU) MenuTool.render();
      if (currentState === STATE_TRACE) TraceTool.render();
    }

    // --- NOTEPAD BUTTONS ---
    btnCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(textArea.value);
        // Visual feedback?
        const originalText = btnCopy.textContent;
        btnCopy.textContent = 'COPIED!';
        setTimeout(() => btnCopy.textContent = originalText, 1000);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    btnPaste.addEventListener('click', async () => {
      try {
        const text = await navigator.clipboard.readText();
        // Insert at cursor position
        const start = textArea.selectionStart;
        const end = textArea.selectionEnd;
        const val = textArea.value;
        textArea.value = val.substring(0, start) + text + val.substring(end);
        textArea.selectionStart = textArea.selectionEnd = start + text.length;
        textArea.focus();
      } catch (err) {
        console.error('Paste failed', err);
      }
    });

    // --- INIT ---
    switchState(STATE_MENU);
  </script>
</body>

</html>