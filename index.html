<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TripCoil Terminal V1.1</title>
  <style>
    :root {
      --bg: #05080a;
      --fg: #b8ffe1;
      --dim: #67d7b3;
      --accent: #19ff9a;
      --warn: #ffd36a;
      --error: #ff5f57;
      --success: #28c840;
      --shadow: rgba(25, 255, 154, .20);
      --border: rgba(25, 255, 154, .20);
    }

    * {
      box-sizing: border-box;
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 30% 20%, #071115 0%, var(--bg) 55%, #030506 100%);
      overflow: hidden;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    .frame {
      width: min(980px, 92vw);
      height: min(620px, 86vh);
      border-radius: 18px;
      border: 1px solid var(--border);
      box-shadow: 0 0 40px var(--shadow);
      overflow: hidden;
      position: relative;
      background: #000;
    }

    .titlebar {
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0 14px;
      background: rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid var(--border);
    }

    .title {
      color: #FF453A;
      text-shadow: 0 0 8px rgba(255, 69, 58, 0.7);
      font-size: 16px;
      font-weight: bold;
      opacity: 1;
      letter-spacing: 1px;
      transition: all 0.3s ease;
    }

    .title.success {
      color: var(--success);
      text-shadow: 0 0 8px rgba(40, 200, 64, 0.7);
    }

    .title.error {
      color: var(--error);
      text-shadow: 0 0 8px rgba(255, 95, 87, 0.7);
    }

    .terminal {
      position: absolute;
      inset: 44px 0 0 0;
      padding: 20px;
      color: var(--fg);
      overflow-y: auto;
      line-height: 1.6;
    }

    .terminal::-webkit-scrollbar {
      width: 8px;
    }

    .terminal::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.3);
    }

    .terminal::-webkit-scrollbar-thumb {
      background: var(--dim);
      border-radius: 4px;
    }

    .prompt {
      color: var(--accent);
      font-weight: 600;
    }

    .input-row {
      display: flex;
      align-items: flex-end;
      flex-wrap: wrap;
      gap: 10px;
      padding: 2px 0;
    }

    .input-group {
      display: inline-flex;
      align-items: center;
      gap: 0;
      min-height: 1.2em;
      vertical-align: bottom;
    }

    .caret {
      display: inline-block;
      width: 9px;
      height: 1.1em;
      background: var(--accent);
      animation: blink 1s infinite;
      vertical-align: middle;
      margin-left: 2px;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    .ghost-input {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
      opacity: 0;
      border: none;
      pointer-events: none;
      z-index: -1;
    }

    .overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: #fff;
      z-index: 100;
      flex-direction: column;
      color: #000;
    }

    .overlay-header {
      height: 40px;
      background: linear-gradient(180deg, #f5f5f5 0%, #e8e8e8 100%);
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      padding: 0 12px;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      font-size: 12px;
      justify-content: space-between;
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.1);
    }

    .overlay-close {
      width: 40px;
      height: 40px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 18px;
      color: #666;
      transition: all 0.2s;
      border-radius: 4px;
    }

    .overlay-close:hover {
      background: #e81123;
      color: #fff;
    }

    .overlay-content {
      flex: 1;
      padding: 15px;
      font-family: 'Consolas', 'Courier New', monospace;
      font-size: 13px;
      border: none;
      outline: none;
      resize: none;
      overflow: auto;
      white-space: pre;
      margin: 0;
      line-height: 1.5;
    }

    textarea.overlay-content {
      background: #fafafa;
    }

    .toolbar {
      display: flex;
      gap: 6px;
      align-items: center;
    }

    .btn {
      background: linear-gradient(180deg, #fff 0%, #e8e8e8 100%);
      border: 1px solid #adadad;
      padding: 4px 12px;
      font-size: 11px;
      cursor: pointer;
      font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
      color: #333;
      border-radius: 3px;
      font-weight: 500;
      transition: all 0.15s;
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.05);
    }

    .btn:hover {
      background: linear-gradient(180deg, #f8f8f8 0%, #d8d8d8 100%);
      border-color: #999;
    }

    .btn:active {
      background: #d0d0d0;
      box-shadow: inset 0 1px 2px rgba(0, 0, 0, 0.1);
    }

    .mobile-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
      opacity: 0.6;
      transition: opacity 0.3s;
    }

    .mobile-controls:hover {
      opacity: 1;
    }

    .history-btn {
      width: 44px;
      height: 44px;
      background: rgba(25, 255, 154, 0.1);
      border: 2px solid var(--accent);
      color: var(--accent);
      font-size: 20px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      backdrop-filter: blur(4px);
      transition: all 0.2s;
      font-weight: bold;
    }

    .history-btn:hover {
      background: rgba(25, 255, 154, 0.2);
      transform: scale(1.05);
    }

    .history-btn:active {
      background: var(--accent);
      color: #000;
      transform: scale(0.95);
    }

    /* Status Colors */
    .ok {
      color: #28a745;
      font-weight: 600;
    }

    .warn {
      color: #fd7e14;
      font-weight: 600;
    }

    .error {
      color: #dc3545;
      font-weight: 600;
    }

    .muted {
      color: #6c757d;
    }

    .success {
      color: var(--success);
      font-weight: 600;
    }

    .info {
      color: var(--accent);
    }

    /* Print-specific styles */
    @media print {
      .overlay-header,
      .btn,
      .overlay-close {
        display: none !important;
      }

      .overlay-content {
        padding: 0;
        font-size: 10pt;
      }
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="titlebar">
      <div class="title" id="main-header">TRIPCOIL TERMINAL V1.1</div>
    </div>
    <div class="terminal" id="terminal">
      <div id="content"></div>
      <input class="ghost-input" id="ghost" type="text" autocomplete="off" spellcheck="false" inputmode="text"
        autofocus>
    </div>

    <!-- CSV Overlay -->
    <div class="overlay" id="csv-overlay">
      <div class="overlay-header">
        <div class="toolbar">
          <span style="font-size: 18px; margin-right: 5px;">üìù</span>
          <button class="btn" id="btn-copy" title="Copy to clipboard">COPY</button>
          <button class="btn" id="btn-paste" title="Paste from clipboard">PASTE</button>
          <button class="btn" id="btn-save" title="Save CSV file">SAVE</button>
          <button class="btn" id="btn-load" title="Load CSV file">LOAD</button>
        </div>
        <div style="position: absolute; left: 50%; transform: translateX(-50%); font-weight: 600; font-size: 13px;">
          DATA INTERFACE
        </div>
        <div class="overlay-close" id="csv-close">‚úï</div>
      </div>
      <textarea class="overlay-content" id="csv-textarea" placeholder="Paste CSV data here or load a file..."></textarea>
    </div>

    <!-- Plotter Overlay -->
    <div class="overlay" id="plotter-overlay">
      <div class="overlay-header">
        <div class="toolbar">
          <span style="font-size: 18px; margin-right: 5px;">üìä</span>
          <button class="btn" id="btn-plot-copy" title="Copy diagram">COPY</button>
          <button class="btn" id="btn-plot-print" title="Print diagram">PRINT</button>
        </div>
        <div style="position: absolute; left: 50%; transform: translateX(-50%); font-weight: 600; font-size: 13px;">
          WIRING DIAGRAM
        </div>
        <div class="overlay-close" id="plotter-close">‚úï</div>
      </div>
      <pre class="overlay-content" id="plotter-content"></pre>
    </div>

    <div class="mobile-controls">
      <div class="history-btn" id="btn-up" title="Undo / History Up">‚àß</div>
      <div class="history-btn" id="btn-down" title="History Down">‚à®</div>
    </div>

    <input type="file" id="file-input" accept=".csv,.txt" style="display:none">
  </div>

  <script>
    'use strict';

    // ========================================
    // CONSTANTS & CONFIGURATION
    // ========================================

    const STATUS = {
      CONFIRMED: 'C',
      UNCONFIRMED: 'U',
      PENDING: '?',
      EMPTY: ''
    };

    const ROW_TYPE = {
      WIRE: 'WIR',
      DEVICE: 'DEV',
      TERMINAL: 'TER'
    };

    const STATE = {
      MENU: 'MENU',
      TRACE: 'TRACE'
    };

    const PHASE = {
      SEED_PANEL: 'SEED_PANEL',
      SEED_DEVICE: 'SEED_DEVICE',
      SEED_TERMINAL: 'SEED_TERMINAL',
      DEST_PANEL: 'DEST_PANEL',
      DEST_DEVICE: 'DEST_DEVICE',
      DEST_TERMINAL: 'DEST_TERMINAL',
      CALLBACK: 'CALLBACK',
      DENSITY: 'DENSITY',
      COMPLETE: 'COMPLETE'
    };

    const CSV_COLUMNS = {
      TYPE: 0,
      PANEL: 1,
      DEVICE: 2,
      TERMINAL: 3,
      TERM_KIND: 4,
      ELEM_ID: 5,
      DEVICE_PART: 6,
      TO_PANEL: 7,
      TO_DEVICE: 8,
      TO_TERMINAL: 9,
      CABLE_ID: 10,
      STATUS: 11,
      SIGNAL_ID: 12,
      REMARKS: 13
    };

    // ========================================
    // DOM REFERENCES
    // ========================================

    const DOM = {
      content: document.getElementById('content'),
      terminal: document.getElementById('terminal'),
      ghost: document.getElementById('ghost'),
      header: document.getElementById('main-header'),

      csvOverlay: document.getElementById('csv-overlay'),
      csvTextarea: document.getElementById('csv-textarea'),
      csvClose: document.getElementById('csv-close'),
      btnCopy: document.getElementById('btn-copy'),
      btnPaste: document.getElementById('btn-paste'),
      btnSave: document.getElementById('btn-save'),
      btnLoad: document.getElementById('btn-load'),

      plotterOverlay: document.getElementById('plotter-overlay'),
      plotterContent: document.getElementById('plotter-content'),
      plotterClose: document.getElementById('plotter-close'),
      btnPlotCopy: document.getElementById('btn-plot-copy'),
      btnPlotPrint: document.getElementById('btn-plot-print'),

      btnUp: document.getElementById('btn-up'),
      btnDown: document.getElementById('btn-down'),
      fileInput: document.getElementById('file-input')
    };

    // ========================================
    // UTILITY FUNCTIONS
    // ========================================

    /**
     * Sanitizes text to prevent XSS attacks
     * @param {string} text - Text to sanitize
     * @returns {string} Sanitized HTML
     */
    function sanitize(text) {
      const div = document.createElement('div');
      div.textContent = text;
      return div.innerHTML;
    }

    /**
     * Normalizes string for comparison (uppercase, trimmed)
     * @param {string} str - String to normalize
     * @returns {string} Normalized string
     */
    function normalize(str) {
      return String(str || '').trim().toUpperCase();
    }

    /**
     * Generates unique key for terminal identification
     * @param {string} panel - Panel identifier
     * @param {string} device - Device identifier
     * @param {string} terminal - Terminal identifier
     * @returns {string} Unique key
     */
    function makeKey(panel, device, terminal) {
      return `${normalize(panel)}|${normalize(device)}|${normalize(terminal)}`;
    }

    /**
     * Debounce function to limit rapid calls
     * @param {Function} func - Function to debounce
     * @param {number} wait - Wait time in ms
     * @returns {Function} Debounced function
     */
    function debounce(func, wait) {
      let timeout;
      return function executedFunction(...args) {
        const later = () => {
          clearTimeout(timeout);
          func(...args);
        };
        clearTimeout(timeout);
        timeout = setTimeout(later, wait);
      };
    }

    // ========================================
    // STATE MANAGER
    // ========================================

    const StateManager = {
      currentState: STATE.MENU,
      inputBuffer: '',
      commandHistory: [],
      historyIndex: -1,
      tempInputBuffer: '',

      setState(newState) {
        this.currentState = newState;
        this.inputBuffer = '';
      },

      addToHistory(command) {
        if (command && command !== this.commandHistory[this.commandHistory.length - 1]) {
          this.commandHistory.push(command);
          this.historyIndex = -1;
          this.tempInputBuffer = '';
        }
      },

      navigateHistory(direction) {
        if (this.commandHistory.length === 0) return;

        if (this.historyIndex === -1 && direction === -1) {
          this.tempInputBuffer = this.inputBuffer;
          this.historyIndex = this.commandHistory.length - 1;
        } else {
          this.historyIndex += direction;
        }

        this.historyIndex = Math.max(-1, Math.min(this.historyIndex, this.commandHistory.length - 1));

        if (this.historyIndex === -1) {
          this.inputBuffer = this.tempInputBuffer;
        } else {
          this.inputBuffer = this.commandHistory[this.historyIndex];
        }
      }
    };

    // ========================================
    // UI RENDERER
    // ========================================

    const UIRenderer = {
      setHeader(text, type = 'normal') {
        DOM.header.textContent = text;
        DOM.header.className = 'title';
        if (type === 'success') DOM.header.classList.add('success');
        if (type === 'error') DOM.header.classList.add('error');
      },

      clearTerminal() {
        DOM.content.innerHTML = '';
      },

      appendLine(html) {
        const div = document.createElement('div');
        div.className = 'term-line';
        div.innerHTML = html;
        DOM.content.appendChild(div);
        this.scrollToBottom();
      },

      removeLastLine() {
        const lines = DOM.content.getElementsByClassName('term-line');
        if (lines.length > 0) {
          lines[lines.length - 1].remove();
        }
      },

      scrollToBottom: debounce(() => {
        DOM.terminal.scrollTop = DOM.terminal.scrollHeight;
      }, 50),

      renderInput(prompt, preContent = '') {
        let active = document.getElementById('active-row');
        if (active) active.remove();

        const container = document.createElement('div');
        container.id = 'active-row';

        if (preContent) {
          const preDiv = document.createElement('div');
          preDiv.className = 'input-pre-content';
          preDiv.innerHTML = preContent;
          container.appendChild(preDiv);
        }

        const row = document.createElement('div');
        row.className = 'input-row';
        row.innerHTML = `<span class="prompt">${prompt}</span> <span class="input-group"><span>${sanitize(StateManager.inputBuffer)}</span><span class="caret"></span></span>`;
        container.appendChild(row);

        DOM.content.appendChild(container);
        this.scrollToBottom();
      },

      commitInput(cmd) {
        const active = document.getElementById('active-row');
        if (active) {
          const promptText = active.querySelector('.prompt').innerHTML;
          active.remove();
          this.appendLine(`${promptText} <span>${sanitize(cmd)}</span>`);
        }
      }
    };

    // ========================================
    // CSV PARSER
    // ========================================

    const CSVParser = {
      /**
       * Parses CSV text into structured row objects
       * @param {string} csvText - Raw CSV text
       * @returns {Array} Array of row objects
       */
      parse(csvText) {
        if (!csvText) return [];

        try {
          return csvText
            .split('\n')
            .map(line => line.trim())
            .filter(line => line && !line.startsWith('#') && !normalize(line).startsWith('ROW_TYPE'))
            .map(line => {
              const cols = line.split(',').map(c => c.trim());
              
              if (cols.length < 14) {
                console.warn('Skipping malformed row:', line);
                return null;
              }

              return {
                type: cols[CSV_COLUMNS.TYPE] || '',
                panel: cols[CSV_COLUMNS.PANEL] || '',
                device: cols[CSV_COLUMNS.DEVICE] || '',
                terminal: cols[CSV_COLUMNS.TERMINAL] || '',
                termKind: cols[CSV_COLUMNS.TERM_KIND] || '',
                elemId: cols[CSV_COLUMNS.ELEM_ID] || '',
                devicePart: cols[CSV_COLUMNS.DEVICE_PART] || '',
                toPanel: cols[CSV_COLUMNS.TO_PANEL] || '',
                toDevice: cols[CSV_COLUMNS.TO_DEVICE] || '',
                toTerminal: cols[CSV_COLUMNS.TO_TERMINAL] || '',
                cableId: cols[CSV_COLUMNS.CABLE_ID] || '',
                status: cols[CSV_COLUMNS.STATUS] || '',
                signalId: cols[CSV_COLUMNS.SIGNAL_ID] || '',
                remarks: cols[CSV_COLUMNS.REMARKS] || ''
              };
            })
            .filter(row => row !== null);
        } catch (error) {
          UIRenderer.appendLine(`<span class="error">CSV PARSE ERROR: ${error.message}</span>`);
          return [];
        }
      },

      /**
       * Converts row objects back to CSV text
       * @param {Array} rows - Array of row objects
       * @returns {string} CSV text
       */
      stringify(rows) {
        const header = "ROW_TYPE,PANEL,DEVICE_TAG,TERMINAL,TERM_KIND,ELEM_ID,DEVICE_PART,TO_PANEL,TO_DEVICE,TO_TERMINAL,CABLE_ID,STATUS,SIGNAL_ID,REMARKS";
        const lines = rows.map(r => {
          return [
            r.type,
            r.panel,
            r.device,
            r.terminal,
            r.termKind,
            r.elemId,
            r.devicePart,
            r.toPanel,
            r.toDevice,
            r.toTerminal,
            r.cableId,
            r.status,
            r.signalId,
            r.remarks
          ].join(',');
        });
        return header + '\n' + lines.join('\n');
      },

      /**
       * Validates CSV structure
       * @param {string} csvText - CSV text to validate
       * @returns {Object} Validation result with isValid flag and errors array
       */
      validate(csvText) {
        const errors = [];
        const lines = csvText.split('\n').filter(l => l.trim() && !l.trim().startsWith('#'));

        lines.forEach((line, idx) => {
          const cols = line.split(',');
          if (cols.length !== 14) {
            errors.push(`Line ${idx + 1}: Expected 14 columns, got ${cols.length}`);
          }
        });

        return {
          isValid: errors.length === 0,
          errors
        };
      }
    };

    // ========================================
    // TRACE TOOL
    // ========================================

    const TraceTool = {
      rows: [],
      phase: PHASE.SEED_PANEL,
      inputs: {},
      currentFrom: null,
      discoveryStack: [],
      undoStack: [],

      init() {
        UIRenderer.clearTerminal();
        UIRenderer.setHeader('');

        this.rows = CSVParser.parse(DOM.csvTextarea.value);
        this.phase = PHASE.SEED_PANEL;
        this.inputs = {};
        this.currentFrom = null;
        this.discoveryStack = [];
        this.undoStack = [];

        this.render();
      },

      /**
       * Saves current state for undo functionality
       * @param {string} processedInput - The input that was just processed
       */
      saveState(processedInput) {
        const snapshot = {
          phase: this.phase,
          inputs: JSON.parse(JSON.stringify(this.inputs)),
          discoveryStack: JSON.parse(JSON.stringify(this.discoveryStack)),
          currentFrom: this.currentFrom ? JSON.parse(JSON.stringify(this.currentFrom)) : null,
          rowsLength: this.rows.length,
          lastInput: processedInput
        };
        this.undoStack.push(snapshot);

        // Limit undo stack to prevent memory issues
        if (this.undoStack.length > 50) {
          this.undoStack.shift();
        }
      },

      /**
       * Undoes the last action
       */
      undo() {
        if (this.undoStack.length === 0) return;

        const snap = this.undoStack.pop();

        // If rows were added, remove them
        if (snap.rowsLength < this.rows.length) {
          this.rows.length = snap.rowsLength;
        }

        this.phase = snap.phase;
        this.inputs = snap.inputs;
        this.discoveryStack = snap.discoveryStack;
        this.currentFrom = snap.currentFrom;

        UIRenderer.removeLastLine();
        StateManager.inputBuffer = snap.lastInput;
        this.render();
      },

      handleInput(val) {
        this.saveState(val);

        switch (this.phase) {
          case PHASE.SEED_PANEL:
            this.handleSeedPanel(val);
            break;
          case PHASE.SEED_DEVICE:
            this.handleSeedDevice(val);
            break;
          case PHASE.SEED_TERMINAL:
            this.handleSeedTerminal(val);
            break;
          case PHASE.DEST_PANEL:
            this.handleDestPanel(val);
            break;
          case PHASE.DEST_DEVICE:
            this.handleDestDevice(val);
            break;
          case PHASE.DEST_TERMINAL:
            this.handleDestTerminal(val);
            break;
          case PHASE.CALLBACK:
            this.handleCallback(val);
            break;
          case PHASE.DENSITY:
            this.handleDensity(val);
            break;
        }

        this.render();
      },

      handleSeedPanel(val) {
        this.inputs.panel = val;
        UIRenderer.appendLine(`<span class="prompt">FROM PANEL:</span> <span>${sanitize(val)}</span>`);
        UIRenderer.setHeader(`üìç    ${this.inputs.panel}    üìç`);
        this.phase = PHASE.SEED_DEVICE;
      },

      handleSeedDevice(val) {
        this.inputs.device = val;
        UIRenderer.appendLine(`<span class="prompt">FROM DEVICE:</span> <span>${sanitize(val)}</span>`);
        UIRenderer.setHeader(`üìç    ${this.inputs.panel} ${this.inputs.device}    üìç`);
        this.phase = PHASE.SEED_TERMINAL;
      },

      handleSeedTerminal(val) {
        this.inputs.terminal = val;
        UIRenderer.appendLine(`<span class="prompt">FROM TERMINAL:</span> <span>${sanitize(val)}</span>`);
        UIRenderer.setHeader(`üìç    ${this.inputs.panel} ${this.inputs.device} ${this.inputs.terminal}    üìç`);

        this.currentFrom = {
          panel: this.inputs.panel,
          device: this.inputs.device,
          terminal: this.inputs.terminal,
          count: 0
        };

        this.startDestinationPhase();
      },

      handleDestPanel(val) {
        this.inputs.toPanel = val;
        UIRenderer.appendLine(`<span class="prompt">TO PANEL:</span> <span>${sanitize(val)}</span>`);
        this.phase = PHASE.DEST_DEVICE;
      },

      handleDestDevice(val) {
        this.inputs.toDevice = val;
        UIRenderer.appendLine(`<span class="prompt">TO DEVICE:</span> <span>${sanitize(val)}</span>`);
        this.phase = PHASE.DEST_TERMINAL;
      },

      handleDestTerminal(val) {
        this.inputs.toTerminal = val;
        UIRenderer.appendLine(`<span class="prompt">TO TERMINAL:</span> <span>${sanitize(val)}</span>`);
        UIRenderer.setHeader(`üìç    ${this.inputs.toPanel} ${this.inputs.toDevice} ${this.inputs.toTerminal}    üìç`);
        UIRenderer.clearTerminal();
        this.phase = PHASE.CALLBACK;
      },

      handleCallback(val) {
        const norm = normalize(val);
        const isYes = norm.startsWith('Y');
        this.inputs.callsBack = isYes ? 'Y' : 'N';

        UIRenderer.appendLine(`<span class="prompt">FOUND WIRE ${this.currentFrom.panel}/${this.currentFrom.device}/${this.currentFrom.terminal}?</span> <span>${this.inputs.callsBack}</span>`);
        UIRenderer.clearTerminal();
        this.phase = PHASE.DENSITY;
      },

      handleDensity(val) {
        const count = parseInt(val, 10);
        if (isNaN(count) || count < 0) {
          UIRenderer.appendLine(`<span class="warn">INVALID NUMBER - ENTER 0 OR GREATER</span>`);
          return;
        }
        UIRenderer.appendLine(`<span class="prompt">WIRE COUNT:</span> <span>${count}</span>`);
        this.processJump(count);
      },

      startDestinationPhase() {
        UIRenderer.clearTerminal();
        this.inputs.toPanel = '';
        this.inputs.toDevice = '';
        this.inputs.toTerminal = '';
        this.inputs.callsBack = '';
        this.phase = PHASE.DEST_PANEL;
      },

      /**
       * Finds matching row in CSV data (bidirectional)
       * @returns {Object|null} Matched row or null
       */
      findMatchingRow() {
        const currentPanel = normalize(this.currentFrom.panel);
        const currentDevice = normalize(this.currentFrom.device);
        const currentTerminal = normalize(this.currentFrom.terminal);
        const toPanel = normalize(this.inputs.toPanel);
        const toDevice = normalize(this.inputs.toDevice);
        const toTerminal = normalize(this.inputs.toTerminal);

        return this.rows.find(r => {
          if (r.type !== ROW_TYPE.WIRE) return false;

          const rowPanel = normalize(r.panel);
          const rowDevice = normalize(r.device);
          const rowTerminal = normalize(r.terminal);
          const rowToPanel = normalize(r.toPanel);
          const rowToDevice = normalize(r.toDevice);
          const rowToTerminal = normalize(r.toTerminal);

          // Forward match
          const forwardMatch = (
            rowPanel === currentPanel &&
            rowDevice === currentDevice &&
            rowTerminal === currentTerminal &&
            rowToPanel === toPanel &&
            rowToDevice === toDevice &&
            rowToTerminal === toTerminal
          );

          // Reverse match
          const reverseMatch = (
            rowPanel === toPanel &&
            rowDevice === toDevice &&
            rowTerminal === toTerminal &&
            rowToPanel === currentPanel &&
            rowToDevice === currentDevice &&
            rowToTerminal === currentTerminal
          );

          return forwardMatch || reverseMatch;
        });
      },

      /**
       * Processes a jump from current terminal to destination
       * @param {number} toCount - Number of wires at destination
       */
      processJump(toCount) {
        const matchedRow = this.findMatchingRow();
        const isConfirmed = (this.inputs.callsBack !== 'N');
        const newStatus = isConfirmed ? STATUS.CONFIRMED : STATUS.UNCONFIRMED;

        if (matchedRow) {
          // Update existing row - ONLY STATUS, no remarks
          matchedRow.status = newStatus;
          matchedRow.remarks = ''; // Clear any old remarks
        } else {
          // Create new row - ONLY STATUS, no remarks
          this.rows.push({
            type: ROW_TYPE.WIRE,
            panel: this.currentFrom.panel,
            device: this.currentFrom.device,
            terminal: this.currentFrom.terminal,
            termKind: '',
            elemId: '',
            devicePart: '',
            toPanel: this.inputs.toPanel,
            toDevice: this.inputs.toDevice,
            toTerminal: this.inputs.toTerminal,
            cableId: '',
            status: newStatus,
            signalId: '',
            remarks: '' // Empty remarks - only C or U in status
          });
        }

        // Update discovery stack
        this.updateDiscoveryStack();

        // Determine next step
        this.handleNextStep(toCount);
      },

      /**
       * Updates discovery stack after processing a wire
       */
      updateDiscoveryStack() {
        const stackIdx = this.discoveryStack.findIndex(n =>
          normalize(n.panel) === normalize(this.currentFrom.panel) &&
          normalize(n.device) === normalize(this.currentFrom.device) &&
          normalize(n.terminal) === normalize(this.currentFrom.terminal)
        );

        if (stackIdx !== -1) {
          this.discoveryStack[stackIdx].count--;
          if (this.discoveryStack[stackIdx].count <= 0) {
            this.discoveryStack.splice(stackIdx, 1);
          }
        }
      },

      /**
       * Handles next step after processing a wire
       * @param {number} toCount - Number of wires at destination
       */
      handleNextStep(toCount) {
        // Check for pending wires at destination in CSV
        const destPending = this.getUnverifiedWires(
          this.inputs.toPanel,
          this.inputs.toDevice,
          this.inputs.toTerminal
        );

        const nextCount = destPending.length > 0 ? destPending.length : toCount;

        if (nextCount > 0) {
          const toNode = {
            panel: this.inputs.toPanel,
            device: this.inputs.toDevice,
            terminal: this.inputs.toTerminal,
            count: nextCount
          };

          this.discoveryStack.push(toNode);
          this.currentFrom = toNode;
          UIRenderer.setHeader(`üìç    ${this.currentFrom.panel} ${this.currentFrom.device} ${this.currentFrom.terminal}    üìç`);
          this.startDestinationPhase();
        } else {
          this.circleBack();
        }
      },

      /**
       * Gets unverified wires for a terminal
       * @param {string} panel - Panel identifier
       * @param {string} device - Device identifier
       * @param {string} terminal - Terminal identifier
       * @returns {Array} Array of unverified rows
       */
      getUnverifiedWires(panel, device, terminal) {
        const normPanel = normalize(panel);
        const normDevice = normalize(device);
        const normTerminal = normalize(terminal);

        return this.rows.filter(r => {
          if (r.type !== ROW_TYPE.WIRE) return false;

          const status = normalize(r.status);
          if (status === STATUS.CONFIRMED || status === STATUS.UNCONFIRMED) return false;

          const rowPanel = normalize(r.panel);
          const rowDevice = normalize(r.device);
          const rowTerminal = normalize(r.terminal);

          return rowPanel === normPanel &&
            rowDevice === normDevice &&
            rowTerminal === normTerminal;
        });
      },

      /**
       * Circles back to previous unfinished terminal
       */
      circleBack() {
        if (this.discoveryStack.length > 0) {
          const nextSrc = this.discoveryStack[this.discoveryStack.length - 1];
          this.currentFrom = nextSrc;
          UIRenderer.setHeader(`üìç    ${this.currentFrom.panel} ${this.currentFrom.device} ${this.currentFrom.terminal}    üìç`);
          UIRenderer.appendLine(`<div class="info">‚Ü∫ CIRCLING BACK TO: ${nextSrc.panel} / ${nextSrc.device} / ${nextSrc.terminal} (${nextSrc.count} REMAINING)</div>`);
          this.startDestinationPhase();
        } else {
          this.completeTrace();
        }
      },

      /**
       * Completes the trace session
       */
      completeTrace() {
        this.phase = PHASE.COMPLETE;
        UIRenderer.setHeader('SESSION COMPLETE', 'success');
        UIRenderer.appendLine('<div class="success">‚úì ALL WIRES VERIFIED - TRACE COMPLETE</div>');
        UIRenderer.appendLine('<div class="prompt">TYPE "EXPORT" TO SAVE CSV OR "PLOT" TO VIEW DIAGRAM</div>');
      },

      /**
       * Renders the queue of wires for current terminal
       * @returns {string} HTML for queue display
       */
      renderQueue() {
        if (!this.currentFrom) return '';

        const currentPanel = normalize(this.currentFrom.panel);
        const currentDevice = normalize(this.currentFrom.device);
        const currentTerminal = normalize(this.currentFrom.terminal);

        // Find all wires connected to current terminal
        const relevantRows = this.rows.filter(r => {
          if (r.type !== ROW_TYPE.WIRE) return false;

          const rowPanel = normalize(r.panel);
          const rowDevice = normalize(r.device);
          const rowTerminal = normalize(r.terminal);
          const rowToPanel = normalize(r.toPanel);
          const rowToDevice = normalize(r.toDevice);
          const rowToTerminal = normalize(r.toTerminal);

          const matchSource = (
            rowPanel === currentPanel &&
            rowDevice === currentDevice &&
            rowTerminal === currentTerminal
          );

          const matchDest = (
            rowToPanel === currentPanel &&
            rowToDevice === currentDevice &&
            rowToTerminal === currentTerminal
          );

          return matchSource || matchDest;
        });

        const formatOther = (r) => {
          const rowPanel = normalize(r.panel);
          const rowDevice = normalize(r.device);
          const rowTerminal = normalize(r.terminal);

          if (
            rowPanel === currentPanel &&
            rowDevice === currentDevice &&
            rowTerminal === currentTerminal
          ) {
            return `${r.toPanel} ${r.toDevice} ${r.toTerminal}`;
          } else {
            return `${r.panel} ${r.device} ${r.terminal}`;
          }
        };

        let output = '';
        const verified = [];
        const unconfirmed = [];
        const pending = [];

        // Categorize wires
        relevantRows.forEach(r => {
          const status = normalize(r.status);

          if (status === STATUS.CONFIRMED) {
            verified.push(r);
          } else if (status === STATUS.UNCONFIRMED) {
            unconfirmed.push(r);
          } else {
            pending.push(r);
          }
        });

        // Render verified wires
        verified.forEach(r => {
          output += `<span class="ok">[ ‚úì ] VERIFIED: ${formatOther(r)}</span><br>`;
        });

        // Render unconfirmed wires
        unconfirmed.forEach(r => {
          output += `<span class="warn">[ ‚úó ] UNCONFIRMED: ${formatOther(r)}</span><br>`;
        });

        // Add spacing if we have both verified/unconfirmed and pending
        if ((verified.length > 0 || unconfirmed.length > 0) && pending.length > 0) {
          output += '<br>';
        }

        // Render pending wires
        pending.forEach(r => {
          output += `<span class="muted">[ ? ] PENDING: ${formatOther(r)}</span><br>`;
        });

        return output;
      },

      render() {
        let label = '';

        switch (this.phase) {
          case PHASE.SEED_PANEL:
            label = 'FROM PANEL?';
            break;
          case PHASE.SEED_DEVICE:
            label = 'FROM DEVICE?';
            break;
          case PHASE.SEED_TERMINAL:
            label = 'FROM TERMINAL?';
            break;
          case PHASE.DEST_PANEL:
            const queue = this.renderQueue();
            UIRenderer.renderInput('TO PANEL?', queue);
            return;
          case PHASE.DEST_DEVICE:
            label = 'TO DEVICE?';
            break;
          case PHASE.DEST_TERMINAL:
            label = 'TO TERMINAL?';
            break;
          case PHASE.CALLBACK:
            label = `FOUND WIRE ${this.currentFrom.panel}/${this.currentFrom.device}/${this.currentFrom.terminal}? (Y/N)`;
            break;
          case PHASE.DENSITY:
            const header = `<span class="muted"><i>EXCLUDING ${this.currentFrom.panel}/${this.currentFrom.device}/${this.currentFrom.terminal}...</i></span><br>`;
            const prompt = `HOW MANY WIRES ON ${this.inputs.toPanel}/${this.inputs.toDevice}/${this.inputs.toTerminal}?`;
            UIRenderer.renderInput(prompt, header);
            return;
          case PHASE.COMPLETE:
            label = 'SESSION COMPLETE - TYPE QUIT';
            break;
        }

        if (label) UIRenderer.renderInput(label);
      }
    };

    // ========================================
    // MENU TOOL
    // ========================================

    const MenuTool = {
      init() {
        UIRenderer.clearTerminal();
        UIRenderer.setHeader('TRIPCOIL TERMINAL V1.1');

        UIRenderer.appendLine('<div style="color:var(--accent);font-size:18px;margin-bottom:10px;">‚ö° SYSTEM READY</div>');
        UIRenderer.appendLine('<span style="color:var(--dim)">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê</span>');
        UIRenderer.appendLine('<span class="prompt">üì¶ AVAILABLE MODULES:</span>');
        UIRenderer.appendLine('   <span class="info">1</span> ‚Üí TRACE TOOL <span class="muted">(Active Verification)</span>');
        UIRenderer.appendLine('');
        UIRenderer.appendLine('<span class="prompt">üõ†Ô∏è  AVAILABLE UTILITIES:</span>');
        UIRenderer.appendLine('   <span class="info">2</span> ‚Üí PLOTTER <span class="muted">(Generate Schematics)</span>');
        UIRenderer.appendLine('   <span class="info">3</span> ‚Üí DATA INTERFACE <span class="muted">(Import/Export CSV)</span>');
        UIRenderer.appendLine('');
        UIRenderer.appendLine('<span class="prompt">‚å®Ô∏è  SYSTEM COMMANDS:</span>');
        UIRenderer.appendLine('   <span class="info">HELP</span> <span class="info">QUIT</span> <span class="info">CLEAR</span>');
        UIRenderer.appendLine('<span style="color:var(--dim)">‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê</span>');

        this.render();
      },

      handleInput(val) {
        const cmd = normalize(val);

        if (cmd === '1' || cmd === 'TRACE' || cmd === 'TRACE TOOL') {
          StateManager.setState(STATE.TRACE);
          TraceTool.init();
        } else if (cmd === '2' || cmd === 'PLOTTER' || cmd === 'PLOT') {
          Plotter.show();
        } else if (cmd === '3' || cmd === 'DATA' || cmd === 'CSV' || cmd === 'EXPORT') {
          DataInterface.open();
        } else {
          UIRenderer.appendLine(`<span class="warn">‚ö† INVALID SELECTION - TRY AGAIN</span>`);
        }
      },

      render() {
        UIRenderer.renderInput('SELECT MODULE OR UTILITY >');
      }
    };

    // ========================================
    // PLOTTER
    // ========================================

    const Plotter = {
      show() {
        let csv = '';

        if (TraceTool.rows && TraceTool.rows.length > 0) {
          csv = CSVParser.stringify(TraceTool.rows);
        } else if (DOM.csvTextarea.value.includes('WIR,')) {
          csv = DOM.csvTextarea.value;
        }

        if (!csv) {
          DOM.plotterContent.innerHTML = '<span class="muted">No data to plot.\n\nStart a trace session or load CSV data first.</span>';
          DOM.plotterOverlay.style.display = 'flex';
          return;
        }

        try {
          const rows = this.parse(csv);
          const graph = this.buildGraph(rows);
          const html = this.renderTree(graph);
          DOM.plotterContent.innerHTML = html;
        } catch (e) {
          console.error(e);
          DOM.plotterContent.innerHTML = `<span class="error">Error rendering plot:\n${e.message}</span>`;
        }

        DOM.plotterOverlay.style.display = 'flex';
      },

      close() {
        DOM.plotterOverlay.style.display = 'none';
        focus();
      },

      parse(csv) {
        const cleanCsv = csv.replace(/(\s)WIR,/g, '\nWIR,');
        return cleanCsv
          .split('\n')
          .map(l => l.trim().split(','))
          .filter(r => r[0] === ROW_TYPE.WIRE && r.length >= 12)
          .map(c => ({
            from: { p: c[1], d: c[2], t: c[3] },
            to: { p: c[7], d: c[8], t: c[9] },
            status: c[11] || ''
          }));
      },

      buildGraph(rows) {
        const nodes = new Map();
        const visited = new Set();

        rows.forEach(r => {
          const fromKey = makeKey(r.from.p, r.from.d, r.from.t);
          const toKey = makeKey(r.to.p, r.to.d, r.to.t);

          if (!nodes.has(fromKey)) {
            nodes.set(fromKey, {
              label: `${r.from.p}/${r.from.d}/${r.from.t}`,
              connections: []
            });
          }

          // Determine status class
          let statusClass = 'muted';
          const status = normalize(r.status);
          if (status === STATUS.CONFIRMED) statusClass = 'ok';
          else if (status === STATUS.UNCONFIRMED) statusClass = 'warn';
          else if (status.includes('!')) statusClass = 'error';

          nodes.get(fromKey).connections.push({
            key: toKey,
            label: `${r.to.p}/${r.to.d}/${r.to.t}`,
            status: statusClass
          });

          visited.add(toKey);
        });

        // Sort connections alphabetically
        nodes.forEach(n => n.connections.sort((a, b) => a.label.localeCompare(b.label)));

        // Find root nodes (not referenced as destinations)
        const roots = [...nodes.keys()].filter(k => !visited.has(k));

        return { nodes, roots };
      },

      renderTree({ nodes, roots }) {
        let output = '';

        const draw = (key, prefix, isRoot) => {
          const node = nodes.get(key);
          const label = node ? node.label : key.split('|').join('/');
          let html = '';

          if (isRoot) html += `<strong>${label}</strong>\n`;
          if (!node) return html;

          node.connections.forEach((conn, idx) => {
            const isLast = idx === node.connections.length - 1;
            const branch = isLast ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ ';
            html += `${prefix}${branch}<span class="${conn.status}">${conn.label}</span>\n`;

            if (nodes.has(conn.key)) {
              const newPrefix = prefix + (isLast ? '    ' : '‚îÇ   ');
              html += draw(conn.key, newPrefix, false);
            }
          });

          return html;
        };

        if (roots.length === 0) {
          return '<span class="warn">No root nodes found.\n\nThis may indicate circular references in your wiring data.</span>';
        }

        roots.forEach(r => output += draw(r, '', true) + '\n');
        return output;
      }
    };

    // ========================================
    // DATA INTERFACE
    // ========================================

    const DataInterface = {
      open() {
        let content = '';

        if (StateManager.currentState === STATE.TRACE && TraceTool.rows.length > 0) {
          content = CSVParser.stringify(TraceTool.rows);
        }

        if (content) {
          DOM.csvTextarea.value = content;
        }

        DOM.csvOverlay.style.display = 'flex';
        DOM.csvTextarea.focus();
      },

      close() {
        DOM.csvOverlay.style.display = 'none';
        focus();
      },

      save() {
        let csv = '';

        if (StateManager.currentState === STATE.TRACE && TraceTool.rows.length > 0) {
          csv = CSVParser.stringify(TraceTool.rows);
        } else {
          csv = DOM.csvTextarea.value;
        }

        if (!csv || csv.trim() === '') {
          UIRenderer.appendLine('<span class="warn">‚ö† NO DATA TO SAVE</span>');
          return;
        }

        // Validate before saving
        const validation = CSVParser.validate(csv);
        if (!validation.isValid) {
          UIRenderer.appendLine('<span class="warn">‚ö† CSV VALIDATION WARNINGS:</span>');
          validation.errors.forEach(err => {
            UIRenderer.appendLine(`<span class="muted">  ${err}</span>`);
          });
        }

        const timestamp = new Date().toISOString().replace(/[:.]/g, '-').slice(0, -5);
        const filename = `TripCoil-${timestamp}.csv`;

        const blob = new Blob([csv], { type: 'text/csv;charset=utf-8;' });
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = filename;
        a.click();
        URL.revokeObjectURL(url);

        UIRenderer.appendLine(`<span class="success">‚úì FILE SAVED: ${filename}</span>`);
      },

      load() {
        DOM.fileInput.click();
      }
    };

    // ========================================
    // GLOBAL COMMANDS
    // ========================================

    const GlobalCommands = {
      handle(cmd) {
        const normalizedCmd = normalize(cmd);

        if (normalizedCmd === 'QUIT' || normalizedCmd === 'EXIT') {
          StateManager.setState(STATE.MENU);
          MenuTool.init();
          return true;
        }

        if (normalizedCmd === 'CLEAR' || normalizedCmd === 'CLS') {
          UIRenderer.clearTerminal();
          this.refreshUI();
          return true;
        }

        if (normalizedCmd === 'HELP' || normalizedCmd === '?') {
          this.showHelp();
          this.refreshUI();
          return true;
        }

        if (normalizedCmd === 'EXPORT' || normalizedCmd === 'TEXT' || normalizedCmd === 'CSV' || normalizedCmd === 'DATA') {
          DataInterface.open();
          return true;
        }

        if (normalizedCmd === 'PLOT' || normalizedCmd === 'PLOTTER') {
          Plotter.show();
          return true;
        }

        if (normalizedCmd === 'SAVE') {
          DataInterface.save();
          this.refreshUI();
          return true;
        }

        if (normalizedCmd === 'LOAD') {
          DataInterface.load();
          return true;
        }

        return false;
      },

      showHelp() {
        UIRenderer.appendLine('<div style="color:var(--dim);font-size:14px;margin:10px 0;">‚îÅ‚îÅ‚îÅ TERMINAL REFERENCE ‚îÅ‚îÅ‚îÅ</div>');
        UIRenderer.appendLine('<div><span class="prompt">NAVIGATION</span></div>');
        UIRenderer.appendLine('  <span class="muted">‚Üë/‚Üì Arrow Keys</span> ‚Üí Command History');
        UIRenderer.appendLine('  <span class="muted">‚àß/‚à® Buttons</span> ‚Üí Mobile History/Undo');
        UIRenderer.appendLine('');
        UIRenderer.appendLine('<div><span class="prompt">DATA OPERATIONS</span></div>');
        UIRenderer.appendLine('  <span class="info">CSV</span> or <span class="info">EXPORT</span> ‚Üí Open Data Interface');
        UIRenderer.appendLine('  <span class="info">SAVE</span> ‚Üí Download CSV (Ctrl+S)');
        UIRenderer.appendLine('  <span class="info">LOAD</span> ‚Üí Upload CSV (Ctrl+O)');
        UIRenderer.appendLine('');
        UIRenderer.appendLine('<div><span class="prompt">VISUALIZATION</span></div>');
        UIRenderer.appendLine('  <span class="info">PLOT</span> or <span class="info">PLOTTER</span> ‚Üí View Wiring Diagram');
        UIRenderer.appendLine('');
        UIRenderer.appendLine('<div><span class="prompt">SYSTEM</span></div>');
        UIRenderer.appendLine('  <span class="info">CLEAR</span> ‚Üí Clear Screen');
        UIRenderer.appendLine('  <span class="info">QUIT</span> or <span class="info">EXIT</span> ‚Üí Return to Menu');
        UIRenderer.appendLine('  <span class="info">HELP</span> or <span class="info">?</span> ‚Üí Show This Reference');
        UIRenderer.appendLine('<div style="color:var(--dim);font-size:14px;margin:10px 0;">‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ</div>');
      },

      refreshUI() {
        if (StateManager.currentState === STATE.MENU) MenuTool.render();
        if (StateManager.currentState === STATE.TRACE) TraceTool.render();
      }
    };

    // ========================================
    // EVENT HANDLERS
    // ========================================

    const focus = () => DOM.ghost.focus();

    // Main click handler
    window.addEventListener('click', focus);

    // Main keyboard handler
    window.addEventListener('keydown', (e) => {
      // Don't intercept when typing in overlays
      if (DOM.csvOverlay.style.display === 'flex' || DOM.plotterOverlay.style.display === 'flex') {
        // Allow Escape to close overlays
        if (e.key === 'Escape') {
          DataInterface.close();
          Plotter.close();
        }
        return;
      }

      focus();

      // Handle keyboard shortcuts
      if (e.ctrlKey || e.metaKey) {
        if (e.key === 's' || e.key === 'S') {
          e.preventDefault();
          DataInterface.save();
          return;
        } else if (e.key === 'o' || e.key === 'O') {
          e.preventDefault();
          DataInterface.load();
          return;
        } else if (e.key === 'l' || e.key === 'L') {
          e.preventDefault();
          UIRenderer.clearTerminal();
          GlobalCommands.refreshUI();
          return;
        }
      }

      // Handle special keys
      if (e.key === 'Enter') {
        const rawCmd = StateManager.inputBuffer.trim();
        const cmd = normalize(rawCmd);

        if (rawCmd) StateManager.addToHistory(rawCmd);
        StateManager.inputBuffer = '';

        // Try global commands first
        if (GlobalCommands.handle(cmd)) return;

        // Route to active tool
        if (StateManager.currentState === STATE.MENU) {
          MenuTool.handleInput(cmd);
        } else if (StateManager.currentState === STATE.TRACE) {
          TraceTool.handleInput(cmd);
        }

        GlobalCommands.refreshUI();

      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (StateManager.currentState === STATE.TRACE) {
          TraceTool.undo();
        } else {
          StateManager.navigateHistory(-1);
          GlobalCommands.refreshUI();
        }

      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        if (StateManager.currentState === STATE.MENU) {
          StateManager.navigateHistory(1);
          GlobalCommands.refreshUI();
        }

      } else if (e.key === 'Backspace') {
        e.preventDefault();
        StateManager.inputBuffer = StateManager.inputBuffer.slice(0, -1);
        GlobalCommands.refreshUI();

      } else if (e.key === 'Escape') {
        DataInterface.close();
        Plotter.close();

      } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        StateManager.inputBuffer += e.key.toUpperCase();
        GlobalCommands.refreshUI();
      }
    });

    // Mobile controls
    DOM.btnUp.addEventListener('click', (e) => {
      e.stopPropagation();
      if (StateManager.currentState === STATE.TRACE) {
        TraceTool.undo();
      } else {
        StateManager.navigateHistory(-1);
        GlobalCommands.refreshUI();
      }
      focus();
    });

    DOM.btnDown.addEventListener('click', (e) => {
      e.stopPropagation();
      if (StateManager.currentState === STATE.MENU) {
        StateManager.navigateHistory(1);
        GlobalCommands.refreshUI();
      }
      focus();
    });

    // CSV interface buttons
    DOM.btnCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(DOM.csvTextarea.value);
        const originalText = DOM.btnCopy.textContent;
        DOM.btnCopy.textContent = '‚úì COPIED';
        setTimeout(() => DOM.btnCopy.textContent = originalText, 1500);
      } catch (err) {
        console.error('Copy failed', err);
        DOM.btnCopy.textContent = '‚úó FAILED';
        setTimeout(() => DOM.btnCopy.textContent = 'COPY', 1500);
      }
    });

    DOM.btnPaste.addEventListener('click', async () => {
      try {
        let text = await navigator.clipboard.readText();
        text = text.replace(/(\s)WIR,/g, '\nWIR,');
        DOM.csvTextarea.value = text;
        DOM.csvTextarea.focus();
        
        const originalText = DOM.btnPaste.textContent;
        DOM.btnPaste.textContent = '‚úì PASTED';
        setTimeout(() => DOM.btnPaste.textContent = originalText, 1500);
      } catch (err) {
        console.error('Paste failed', err);
        DOM.btnPaste.textContent = '‚úó FAILED';
        setTimeout(() => DOM.btnPaste.textContent = 'PASTE', 1500);
      }
    });

    DOM.btnSave.addEventListener('click', () => DataInterface.save());
    DOM.btnLoad.addEventListener('click', () => DataInterface.load());
    DOM.csvClose.addEventListener('click', () => DataInterface.close());

    // Plotter buttons
    DOM.btnPlotCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(DOM.plotterContent.innerText);
        const originalText = DOM.btnPlotCopy.textContent;
        DOM.btnPlotCopy.textContent = '‚úì COPIED';
        setTimeout(() => DOM.btnPlotCopy.textContent = originalText, 1500);
      } catch (err) {
        console.error('Copy failed', err);
        DOM.btnPlotCopy.textContent = '‚úó FAILED';
        setTimeout(() => DOM.btnPlotCopy.textContent = 'COPY', 1500);
      }
    });

    DOM.btnPlotPrint.addEventListener('click', () => {
      const printWindow = window.open('', '', 'width=900,height=700');
      printWindow.document.write(`
        <!DOCTYPE html>
        <html>
        <head>
          <title>TripCoil Wiring Diagram - ${new Date().toLocaleDateString()}</title>
          <style>
            @page { margin: 1cm; }
            body {
              font-family: 'Consolas', 'Courier New', monospace;
              white-space: pre;
              font-size: 10pt;
              line-height: 1.4;
              color: #000;
            }
            .ok { color: #000; font-weight: bold; }
            .warn { color: #000; text-decoration: underline; }
            .error { color: #000; font-style: italic; }
            .muted { color: #666; }
            strong { font-weight: bold; }
          </style>
        </head>
        <body>
          <h3>TripCoil Terminal - Wiring Diagram</h3>
          <p>Generated: ${new Date().toLocaleString()}</p>
          <hr>
          ${DOM.plotterContent.innerHTML}
        </body>
        </html>
      `);
      printWindow.document.close();
      printWindow.focus();
      
      setTimeout(() => {
        printWindow.print();
        printWindow.close();
      }, 250);
    });

    DOM.plotterClose.addEventListener('click', () => Plotter.close());

    // File input handler
    DOM.fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const content = event.target.result;
        const fixedContent = content.replace(/(\s)WIR,/g, '\nWIR,');
        
        // Validate before loading
        const validation = CSVParser.validate(fixedContent);
        
        DOM.csvTextarea.value = fixedContent;
        
        if (validation.isValid) {
          UIRenderer.appendLine(`<span class="success">‚úì FILE LOADED: ${file.name}</span>`);
        } else {
          UIRenderer.appendLine(`<span class="warn">‚ö† FILE LOADED WITH WARNINGS: ${file.name}</span>`);
          validation.errors.slice(0, 3).forEach(err => {
            UIRenderer.appendLine(`<span class="muted">  ${err}</span>`);
          });
        }
        
        DOM.fileInput.value = '';
        GlobalCommands.refreshUI();
      };
      
      reader.onerror = () => {
        UIRenderer.appendLine(`<span class="error">‚úó FILE READ ERROR</span>`);
        DOM.fileInput.value = '';
      };
      
      reader.readAsText(file);
    });

    // ========================================
    // INITIALIZATION
    // ========================================

    // Prevent accidental page closure
    window.addEventListener('beforeunload', (e) => {
      if (StateManager.currentState === STATE.TRACE && TraceTool.rows.length > 0) {
        e.preventDefault();
        e.returnValue = 'You have unsaved trace data. Are you sure you want to leave?';
        return e.returnValue;
      }
    });

    // Initialize application
    MenuTool.init();
  </script>
</body>

</html>
