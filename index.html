<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TripCoil Terminal V1.1</title>
  <style>
    :root {
      --bg: #05080a;
      --fg: #b8ffe1;
      --dim: #67d7b3;
      --accent: #19ff9a;
      --warn: #ffd36a;
      --shadow: rgba(25, 255, 154, .20);
      --scan: rgba(25, 255, 154, .06);
      --border: rgba(25, 255, 154, .20);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 30% 20%, #071115 0%, var(--bg) 55%, #030506 100%);
      overflow: hidden;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    .frame {
      width: min(980px, 92vw);
      height: min(620px, 86vh);
      border-radius: 18px;
      border: 1px solid var(--border);
      box-shadow: 0 0 40px var(--shadow);
      overflow: hidden;
      position: relative;
      background: #000;
    }

    .titlebar {
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      /* Center header title */
      padding: 0 14px;
      background: rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid var(--border);
    }

    .title {
      color: #FF453A;
      /* High-visibility Signal Red */
      text-shadow: 0 0 8px rgba(255, 69, 58, 0.7);
      /* Subtle glow */
      font-size: 16px;
      font-weight: bold;
      font-family: inherit;
      opacity: 1;
      letter-spacing: 1px;
      /* Improves legibility */
    }

    .header.green {
      color: #28c840;
      font-weight: bold;
    }

    .header.red {
      color: #ff5f57;
      font-weight: bold;
    }

    .terminal {
      position: absolute;
      inset: 44px 0 0 0;
      padding: 20px;
      color: var(--fg);
      overflow-y: auto;
    }

    .prompt {
      color: var(--accent);
    }

    .input-row {
      display: flex;
      align-items: center;
      /* Fix for baseline jitter */
      gap: 10px;
      padding: 2px 0;
    }

    .input-row.multi-line {
      display: block;
    }

    .input-group {
      display: inline-flex;
      align-items: center;
      /* Ensure caret and text align vertically */
      gap: 0;
      min-height: 1.2em;
      vertical-align: bottom;
      /* Ensure height creates stability even if empty */
    }

    .caret {
      display: inline-block;
      width: 9px;
      height: 1.1em;
      background: var(--accent);
      animation: blink 1s infinite;
      vertical-align: middle;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    /* Fix for Safari/Brave focus */
    .ghost-input {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
      opacity: 0;
      border: none;
      pointer-events: none;
      z-index: -1;
    }

    .notepad-overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: #fff;
      z-index: 100;
      flex-direction: column;
      color: #000;
    }

    .notepad-header {
      height: 32px;
      background: #eee;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-family: sans-serif;
      font-size: 12px;
    }

    .notepad-close {
      margin-left: auto;
      width: 45px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .notepad-close:hover {
      background: #e81123;
      color: #fff;
    }

    .notepad-content {
      flex: 1;
      padding: 15px;
      font-family: 'Consolas', monospace;
      font-size: 14px;
      border: none;
      outline: none;
      resize: none;
    }

    .edit-menu {
      display: flex;
      gap: 8px;
      margin-left: 15px;
    }

    .cmd-btn {
      background: #e0e0e0;
      border: 1px solid #b0b0b0;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      font-family: sans-serif;
      color: #333;
    }

    .cmd-btn:hover {
      background: #d0d0d0;
      border-color: #999;
    }

    .cmd-btn:active {
      background: #ccc;
    }

    /* Mobile Controls */
    .mobile-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
      opacity: 0.6;
    }

    .mobile-controls:hover {
      opacity: 1;
    }

    .history-btn {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--accent);
      color: var(--accent);
      font-size: 20px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      backdrop-filter: blur(2px);
    }

    .history-btn:active {
      background: var(--accent);
      color: #000;
    }

    /* Plotter Styles */
    .plotter-overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: #fff;
      z-index: 100;
      flex-direction: column;
      color: #000;
    }

    .plotter-header {
      height: 32px;
      background: #eee;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-family: sans-serif;
      font-size: 12px;
    }

    .plotter-content {
      flex: 1;
      padding: 15px;
      font-family: 'Consolas', monospace;
      font-size: 12px;
      border: none;
      outline: none;
      overflow: auto;
      white-space: pre;
      margin: 0;
    }

    /* Plotter Colors */
    .ok {
      color: #28a745;
    }

    .warn {
      color: #fd7e14;
    }

    .bad {
      color: #dc3545;
    }

    .muted {
      color: #6c757d;
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="titlebar">
      <div class="title" id="main-header">TRIPCOIL TERMINAL V1.1</div>
    </div>
    <div class="terminal" id="terminal">
      <div id="content"></div>
      <input class="ghost-input" id="ghost" type="text" autocomplete="off" spellcheck="false" inputmode="email"
        autofocus>
    </div>

    <div class="notepad-overlay" id="notepad-overlay">
      <div class="notepad-header" style="position: relative; justify-content: space-between;">
        <!-- Left: Icon + Buttons -->
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 18px; margin-right: 5px;">üìù</span>
          <div class="edit-menu" style="margin-left: 0;">
            <button class="cmd-btn" id="btn-copy">COPY</button>
            <button class="cmd-btn" id="btn-paste">PASTE</button>
          </div>
        </div>

        <!-- Center: Title -->
        <div
          style="position: absolute; left: 50%; transform: translateX(-50%); font-weight: bold; font-size: 14px; text-transform: uppercase; text-shadow: 1px 1px 0 #fff, 2px 2px 2px rgba(0,0,0,0.2);">
          DATA INTERFACE
        </div>

        <!-- Right: Close -->
        <div class="notepad-close" onclick="closeNotepad()" style="margin-left: 0;">‚úï</div>
      </div>
      <textarea class="notepad-content" id="notepad-textarea"></textarea>
    </div>

    <div class="plotter-overlay" id="plotter-overlay">
      <div class="plotter-header" style="position: relative; justify-content: space-between;">
        <!-- Left: Icon + Buttons -->
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 18px; margin-right: 5px;">üìù</span>
          <div class="edit-menu" style="margin-left: 0;">
            <button class="cmd-btn" id="btn-plot-copy">COPY</button>
            <button class="cmd-btn" id="btn-plot-print">PRINT</button>
          </div>
        </div>

        <!-- Center: Title -->
        <div
          style="position: absolute; left: 50%; transform: translateX(-50%); font-weight: bold; font-size: 14px; text-transform: uppercase; text-shadow: 1px 1px 0 #fff, 2px 2px 2px rgba(0,0,0,0.2);">
          PLOTTER
        </div>

        <!-- Right: Close -->
        <div class="notepad-close" onclick="closePlotter()" style="margin-left: 0;">‚úï</div>
      </div>
      <pre class="plotter-content" id="plotter-content"></pre>
    </div>

    <div class="mobile-controls">
      <div class="history-btn" id="btn-up">‚àß</div>
      <div class="history-btn" id="btn-down">‚à®</div>
    </div>

    <!-- Hidden File Input for LOAD command -->
    <input type="file" id="file-input" accept=".csv" style="display:none">
  </div>

  <script>
    const content = document.getElementById('content');
    const terminal = document.getElementById('terminal');
    const ghost = document.getElementById('ghost');
    const overlay = document.getElementById('notepad-overlay');
    const textArea = document.getElementById('notepad-textarea');
    const btnCopy = document.getElementById('btn-copy');
    const btnPaste = document.getElementById('btn-paste');
    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');

    const mainHeader = document.getElementById('main-header'); // Cached ref

    // Plotter Refs
    const plotterOverlay = document.getElementById('plotter-overlay');
    const plotterContent = document.getElementById('plotter-content');
    const btnPlotCopy = document.getElementById('btn-plot-copy');
    const btnPlotPrint = document.getElementById('btn-plot-print');

    // Load Ref
    const fileInput = document.getElementById('file-input');

    // --- STATE MANAGEMENT ---
    const STATE_MENU = 'MENU';
    const STATE_TRACE = 'TRACE';
    let currentState = STATE_MENU;

    // --- SHARED UTILS ---
    let inputBuffer = '';

    // History
    const commandHistory = [];
    let historyIndex = -1;
    let tempInputBuffer = '';

    function setHeader(text, type = 'normal') {
      mainHeader.textContent = text;
      mainHeader.className = 'title'; // Reset
      if (type === 'green') mainHeader.className += ' header green';
      if (type === 'red') mainHeader.className += ' header red';
    }

    function clearTerminal() {
      content.innerHTML = '';
      inputBuffer = '';
    }

    function appendLine(html) {
      const div = document.createElement('div');
      div.className = 'term-line'; // Class for easier removal
      div.innerHTML = html;
      content.appendChild(div);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function removeLastLine() {
      const lines = content.getElementsByClassName('term-line');
      if (lines.length > 0) {
        lines[lines.length - 1].remove();
      }
    }

    function renderInput(prompt, isMultiLine = false) {
      let active = document.getElementById('active-row');
      if (active) active.remove();

      const row = document.createElement('div');
      row.id = 'active-row';
      row.className = 'input-row';
      if (isMultiLine) row.classList.add('multi-line');

      // Using the robust .input-group fix
      row.innerHTML = `<span class="prompt">${prompt}</span> <span class="input-group"><span>${inputBuffer}</span><span class="caret"></span></span>`;
      content.appendChild(row);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function commitInput(cmd) {
      const active = document.getElementById('active-row');
      const promptText = active ? active.querySelector('.prompt').innerHTML : '>';
      // Instead of removing, we transform it into a static line (remove ID, remove caret)
      if (active) {
        active.removeAttribute('id');
        const caret = active.querySelector('.caret');
        if (caret) caret.remove();
        // Or simply replace with static text to ensure cleanliness
        // But matching exact plan:
        // appendLine(`${promptText} <span>${cmd}</span>`);
        // The plan said: "remove active, appendLine".
        active.remove(); // Remove blinking one
        appendLine(`${promptText} <span>${cmd}</span>`); // Add static one
      }
    }

    // --- HISTORY LOGIC ---
    function navigateHistory(direction) {
      if (commandHistory.length === 0) return;

      if (historyIndex === -1 && direction === -1) {
        tempInputBuffer = inputBuffer;
        historyIndex = commandHistory.length - 1;
      } else {
        historyIndex += direction;
      }

      if (historyIndex < -1) historyIndex = -1;
      if (historyIndex >= commandHistory.length) historyIndex = commandHistory.length - 1;

      if (historyIndex === -1) {
        inputBuffer = tempInputBuffer;
      } else {
        inputBuffer = commandHistory[historyIndex];
      }
      refreshUI();
    }

    // --- MOBILE BUTTONS ---
    if (btnUp && btnDown) {
      btnUp.addEventListener('click', (e) => {
        e.stopPropagation();
        // Undo Action
        if (currentState === STATE_TRACE) {
          TraceTool.undo();
        } else {
          navigateHistory(-1); // Menu context
        }
        focus();
      });
      btnDown.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentState === STATE_MENU) navigateHistory(1);
        focus();
      });
    }

    // --- MAIN MENU PROGRAM ---
    const MenuTool = {
      init() {
        clearTerminal();
        setHeader('TRIPCOIL TERMINAL V1.1');
        // Visual Layout
        appendLine('----------------------------------------');
        appendLine('<span class="prompt">AVAILABLE MODULES:</span>');
        appendLine('&nbsp;&nbsp;1. TRACE TOOL (Active Verification)');
        appendLine('<br>');
        appendLine('<span class="prompt">AVAILABLE UTILITIES:</span>');
        appendLine('&nbsp;&nbsp;2. PLOTTER (Generate Schematics)');
        appendLine('&nbsp;&nbsp;3. DATA INTERFACE (Import/Export CSV)');
        appendLine('&nbsp;&nbsp;4. SETTINGS');
        appendLine('<br>');
        appendLine('<span class="prompt">SYSTEM COMMANDS:</span>');
        appendLine('&nbsp;&nbsp;HELP, QUIT, CLEAR');
        appendLine('----------------------------------------');
        inputBuffer = '';
        this.render();
      },
      handleInput(val) {
        if (val === '1' || val === 'TRACE' || val === 'TRACE TOOL') {
          switchState(STATE_TRACE);
        } else if (val === '2' || val === 'PLOTTER' || val === 'PLOT') {
          Plotter.show();
        } else if (val === '3' || val === 'DATA' || val === 'CSV' || val === 'EXPORT') {
          openNotepad();
        } else if (val === '4' || val === 'SETTINGS' || val === 'SET') {
          appendLine(`<span class="warn">SETTINGS MODULE NOT LOADED</span>`);
        } else {
          appendLine(`<span style="color:var(--warn)">INVALID SELECTION</span>`);
        }
      },
      render() {
        renderInput('SELECT MODULE OR UTILITY>');
      }
    };


    // --- PLOTTER TOOL ---
    const Plotter = {
      show() {
        let csv = '';
        if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
          csv = TraceTool.history.map(h => `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${h.status}${h.callsBack === 'N' ? '!' : ''},,`).join('\n');
        } else if (textArea.value.includes('WIR,')) {
          // Fallback: try to read from notepad if it has data
          csv = textArea.value;
        }

        if (!csv) {
          plotterContent.innerHTML = '<span class="muted">No data to plot. Start a trace or export first.</span>';
          plotterOverlay.style.display = 'flex';
          return;
        }

        try {
          const rows = this.parse(csv);
          const graph = this.buildGraph(rows);
          const html = this.renderTree(graph);
          plotterContent.innerHTML = html;
        } catch (e) {
          console.error(e);
          plotterContent.innerHTML = `<span class="bad">Error rendering plot: ${e.message}</span>`;
        }
        plotterOverlay.style.display = 'flex';
      },
      close() {
        plotterOverlay.style.display = 'none';
        focus();
      },
      parse(csv) {
        // Auto-fix missing newlines for WIR rows (robustness for bad copy-paste)
        const cleanCsv = csv.replace(/(\s)WIR,/g, '\nWIR,');
        return cleanCsv.split('\n').map(l => l.trim().split(',')).filter(r => r[0] === 'WIR').map(c => ({
          from: { p: c[1], d: c[2], t: c[3] }, to: { p: c[7], d: c[8], t: c[9] }, status: c[11]
        }));
      },
      buildGraph(rows) {
        const nodes = new Map();
        const visited = new Set();
        const k = (p, d, t) => `${p}|${d}|${t}`;
        rows.forEach(r => {
          const fk = k(r.from.p, r.from.d, r.from.t);
          const tk = k(r.to.p, r.to.d, r.to.t);
          if (!nodes.has(fk)) nodes.set(fk, { l: `${r.from.p}/${r.from.d}/${r.from.t}`, conns: [] });

          let s = 'muted';
          if (r.status === 'C' || r.status === '.') s = 'ok';
          else if (r.status && r.status.includes('!')) s = 'bad';
          else if (r.status && r.status.endsWith('?')) s = 'warn';

          nodes.get(fk).conns.push({ k: tk, l: `${r.to.p}/${r.to.d}/${r.to.t}`, s: s });
          visited.add(tk);
        });
        nodes.forEach(n => n.conns.sort((a, b) => a.l.localeCompare(b.l)));
        const roots = [...nodes.keys()].filter(k => !visited.has(k));
        return { nodes, roots };
      },
      renderTree({ nodes, roots }) {
        let out = '';
        const draw = (key, pfx, isRoot) => {
          const n = nodes.get(key);
          const lbl = n ? n.l : key.split('|').join('/');
          let h = '';

          if (isRoot) h += `${lbl}\n`;
          if (!n) return h;

          n.conns.forEach((c, i) => {
            const last = i === n.conns.length - 1;
            h += `${pfx}${last ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}<span class="${c.s}">${c.l}</span>\n`;
            if (nodes.has(c.k)) {
              h += draw(c.k, pfx + (last ? '    ' : '‚îÇ   '), false);
            }
          });
          return h;
        };
        roots.forEach(r => out += draw(r, '', true) + '\n');
        return out || 'No roots found.';
      }
    };
    window.closePlotter = () => Plotter.close();

    // --- TRACE TOOL PROGRAM (LOOP-BACK & BRANCH) ---
    const TraceTool = {
      // State
      discoveryStack: [], // Renamed from stack
      history: [],
      inputs: {},
      phase: 'SEED',
      currentFrom: null,
      undoStack: [], // Snapshots

      // Constants
      PHASE: {
        SEED_PANEL: 'SEED_PANEL',
        SEED_DEVICE: 'SEED_DEVICE',
        SEED_TERMINAL: 'SEED_TERMINAL',

        DEST_PANEL: 'DEST_PANEL',
        DEST_DEVICE: 'DEST_DEVICE',
        DEST_TERMINAL: 'DEST_TERMINAL',

        CALLBACK: 'CALLBACK',
        DENSITY: 'DENSITY',

        COMPLETE: 'COMPLETE'
      },

      init() {
        clearTerminal();
        setHeader(''); // Initially blank as requested
        this.discoveryStack = [];
        this.history = [];
        this.undoStack = [];
        this.inputs = {};
        this.currentFrom = null;
        this.phase = this.PHASE.SEED_PANEL;
        inputBuffer = '';
        this.render();
      },

      saveState(processedInput) {
        // Serialize current state
        const snapshot = {
          phase: this.phase,
          inputs: JSON.parse(JSON.stringify(this.inputs)),
          discoveryStack: JSON.parse(JSON.stringify(this.discoveryStack)),
          history: JSON.parse(JSON.stringify(this.history)),
          currentFrom: this.currentFrom ? JSON.parse(JSON.stringify(this.currentFrom)) : null,
          lastInput: processedInput
        };
        this.undoStack.push(snapshot);
      },

      undo() {
        if (this.undoStack.length === 0) return;

        const snap = this.undoStack.pop();

        // Restore
        this.phase = snap.phase;
        this.inputs = snap.inputs;
        this.discoveryStack = snap.discoveryStack;
        this.history = snap.history;
        this.currentFrom = snap.currentFrom;

        // Visual: Remove last line
        removeLastLine();

        // Input: Restore what they typed
        inputBuffer = snap.lastInput;

        this.render();
      },

      handleInput(val) {
        this.saveState(val); // Undo point -> Current State + The Input being processed

        const P = this.PHASE;

        switch (this.phase) {
          // --- SEED PHASE ---
          case P.SEED_PANEL:
            this.inputs.p = val;
            appendLine(`<span class="prompt">FROM PANEL:</span> <span>${val}</span>`);
            setHeader(`üìç    ${this.inputs.p}    üìç`);
            this.phase = P.SEED_DEVICE;
            break;

          case P.SEED_DEVICE:
            this.inputs.d = val;
            appendLine(`<span class="prompt">FROM DEVICE:</span> <span>${val}</span>`);
            setHeader(`üìç    ${this.inputs.p} ${this.inputs.d}    üìç`);
            this.phase = P.SEED_TERMINAL;
            break;

          case P.SEED_TERMINAL:
            this.inputs.t = val;
            appendLine(`<span class="prompt">FROM TERMINAL:</span> <span>${val}</span>`);
            // Seed established. Initialize currentFrom.
            // Update Header to full Seed
            setHeader(`üìç    ${this.inputs.p} ${this.inputs.d} ${this.inputs.t}    üìç`);

            this.currentFrom = { p: this.inputs.p, d: this.inputs.d, t: this.inputs.t, count: 0 };

            // Note: startDestinationPhase() now handles clearing the screen
            this.startDestinationPhase();
            break;

          // --- DESTINATION PHASE ---
          case P.DEST_PANEL:
            this.inputs.toP = val;
            appendLine(`<span class="prompt">TO PANEL:</span> <span>${val}</span>`);
            this.phase = P.DEST_DEVICE;
            break;

          case P.DEST_DEVICE:
            this.inputs.toD = val;
            appendLine(`<span class="prompt">TO DEVICE:</span> <span>${val}</span>`);
            this.phase = P.DEST_TERMINAL;
            break;

          case P.DEST_TERMINAL:
            this.inputs.toT = val;
            appendLine(`<span class="prompt">TO TERMINAL:</span> <span>${val}</span>`);

            // Immediate Transition: Update Header & Clear Screen
            setHeader(`üìç    ${this.inputs.toP} ${this.inputs.toD} ${this.inputs.toT}    üìç`);
            clearTerminal();

            this.phase = P.CALLBACK;
            break;

          // --- CALLBACK PHASE ---
          case P.CALLBACK:
            const norm = val.toUpperCase().trim();
            const isYes = norm.startsWith('Y');
            this.inputs.callsBack = isYes ? 'Y' : 'N';

            appendLine(`<span class="prompt">FOUND WIRE ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}?</span> <span>${this.inputs.callsBack}</span>`);

            // Update Header Color (Temporary for Callback Check)
            // User requested header remains static with FROM loc until TO TERM entered.
            // But this is the check step. Maybe we keep the static header or show the check?
            // Header updated in DEST_TERMINAL now.
            // setHeader(`üìç    ${this.inputs.toP} ${this.inputs.toD} ${this.inputs.toT}    üìç`);

            clearTerminal(); // Clear before asking Density
            this.phase = P.DENSITY;
            break;

          // --- DENSITY PHASE ---
          case P.DENSITY:
            const count = parseInt(val);
            if (isNaN(count)) {
              appendLine(`<span style="color:var(--warn)">INVALID NUMBER</span>`);
              this.render();
              return;
            }
            appendLine(`<span class="prompt">BESIDES ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}, HOW MANY WIRES ON ${this.inputs.toP}/${this.inputs.toD}/${this.inputs.toT}?</span> <span>${val}</span>`);
            this.processJump(count);
            break;
        }

        this.render();
      },

      startDestinationPhase() {
        clearTerminal(); // Clear history when starting a new leg
        this.inputs.toP = '';
        this.inputs.toD = '';
        this.inputs.toT = ''; // Clear destination buffer
        this.inputs.callsBack = '';
        this.phase = this.PHASE.DEST_PANEL;
      },

      markHistoryComplete(term) {
        // Update any history records where this terminal was the destination
        this.history.forEach(h => {
          if (h.to.p === term.p && h.to.d === term.d && h.to.t === term.t) {
            h.status = 'C';
          }
        });
      },

      processJump(toCount) {
        // 1. Determine Status (Column 12)
        // Default: If count > 0, it's pending ("Count?"). If 0, it's Complete ("C").
        const status = toCount > 0 ? `${toCount}?` : 'C';

        // 2. Record WIR Row
        // Mapping: From(2,3,4) -> To(8,9,10) ... Status(12)
        this.history.push({
          from: { p: this.currentFrom.p, d: this.currentFrom.d, t: this.currentFrom.t },
          to: { p: this.inputs.toP, d: this.inputs.toD, t: this.inputs.toT },
          callsBack: this.inputs.callsBack,
          status: status
        });

        appendLine(`<div style="color:var(--dim)">> TRACED: ${this.currentFrom.t} -> ${this.inputs.toT} [${status}]</div>`);

        // 3. Update Discovery Stack (The Countdown)
        // If currentFrom is in discoveryStack, decrement it.
        // We need to find the specific reference in the discoveryStack.
        const stackIdx = this.discoveryStack.findIndex(n =>
          n.p === this.currentFrom.p && n.d === this.currentFrom.d && n.t === this.currentFrom.t
        );

        if (stackIdx !== -1) {
          this.discoveryStack[stackIdx].count--;
          if (this.discoveryStack[stackIdx].count <= 0) {
            this.markHistoryComplete(this.discoveryStack[stackIdx]);
            this.discoveryStack.splice(stackIdx, 1); // Remove completed
            // appendLine(`<div style="color:var(--dim)">> ${this.currentFrom.t} COMPLETED</div>`);
          } else {
            // appendLine(`<div style="color:var(--dim)">> ${this.currentFrom.t} PENDING (${this.discoveryStack[stackIdx].count})</div>`);
          }
        }

        // 4. Handle "To" Terminal
        const toNode = {
          p: this.inputs.toP,
          d: this.inputs.toD,
          t: this.inputs.toT,
          count: toCount
        };

        if (toCount > 0) {
          // Push To Node to Discovery Stack (Step E)
          this.discoveryStack.push(toNode);

          // Move forward: To becomes From
          this.currentFrom = toNode;

          // UPDATE HEADER NOW (Jump Confirmed)
          setHeader(`üìç    ${this.currentFrom.p} ${this.currentFrom.d} ${this.currentFrom.t}    üìç`);

          this.startDestinationPhase();
        } else {
          // Dead End (Step F)
          // Circle Back
          this.circleBack();
        }
      },

      circleBack() {
        if (this.discoveryStack.length > 0) {
          // Pull most recent from Active Discovery Stack
          const nextSrc = this.discoveryStack[this.discoveryStack.length - 1]; // Peek/Get
          this.currentFrom = nextSrc;

          // Update Header on Circle Back
          setHeader(`üìç    ${this.currentFrom.p} ${this.currentFrom.d} ${this.currentFrom.t}    üìç`);

          appendLine(`<div style="color:var(--accent)">‚Ü∫ CIRCLING BACK TO: ${nextSrc.p} / ${nextSrc.d} / ${nextSrc.t} (${nextSrc.count} LEFT)</div>`);

          this.startDestinationPhase();
        } else {
          // Session Complete
          this.phase = this.PHASE.COMPLETE;
          setHeader('SESSION COMPLETE', 'green');
          appendLine('<div style="color:var(--warn)">NO PENDING WIRES - TRACE COMPLETE</div>');
          appendLine('<div class="prompt">TYPE "EXPORT" TO SAVE CSV</div>');
        }
      },

      render() {
        let label = '';
        const P = this.PHASE;

        switch (this.phase) {
          case P.SEED_PANEL: label = 'FROM PANEL?'; break;
          case P.SEED_DEVICE: label = 'FROM DEVICE?'; break;
          case P.SEED_TERMINAL: label = 'FROM TERMINAL?'; break;

          case P.DEST_PANEL:
            // "Take out the blue text that says FROM: ..."
            label = 'TO PANEL:';
            break;
          case P.DEST_DEVICE: label = 'TO DEVICE?'; break;
          case P.DEST_TERMINAL: label = 'TO TERMINAL?'; break;

          case P.CALLBACK:
            label = `FOUND WIRE ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}? (Y/N)`;
            break;

          case P.DENSITY:
            label = `<i>EXCLUDING ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}...</i><br>HOW MANY WIRES ON<br>${this.inputs.toP}/${this.inputs.toD}/${this.inputs.toT}?`;
            break;

          case P.COMPLETE: label = 'COMPLETE (TYPE QUIT)'; break;
        }

        if (label) renderInput(label, this.phase === P.DENSITY);
      }
    };

    // --- GLOBAL HANDLERS ---

    function switchState(newState) {
      currentState = newState;
      if (newState === STATE_MENU) MenuTool.init();
      if (newState === STATE_TRACE) TraceTool.init();
    }

    function showHelp() {
      appendLine('<div style="color:var(--dim)">--- TERMINAL CHEATSHEET ---</div>');
      appendLine('<div><span class="prompt">NAVIGATION:</span> Up/Down Arrow for Command History</div>');
      appendLine('<div><span class="prompt">MOBILE:</span> Use virtual buttons (‚àß/‚à®) for history/undo</div>');
      appendLine('<div><span class="prompt">DATA:</span> TYPE "CSV" (or EXPORT) for Data Interface</div>');
      appendLine('<div><span class="prompt">PLOT:</span> TYPE "PLOT" (or PLOTTER) for Wiring Diagram</div>');
      appendLine('<div><span class="prompt">FILE:</span> SAVE (Download CSV), LOAD (Open CSV)</div>');
      appendLine('<div><span class="prompt">SYSTEM:</span> CLEAR, QUIT (or EXIT), HELP</div>');
      appendLine('<div style="color:var(--dim)">---------------------------</div>');
    }

    function openNotepad() {
      // Generate CSV from History
      let content = '';

      if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
        // CSV Mapping:
        // 2,3,4 = From P,D,T
        // 8,9,10 = To P,D,T
        // 12 = Status
        // Note: Header color (callsBack) logic not explicitly mapped to a specific CSV column in 'Specification' table 
        // EXCEPT "Header Color (Green = Y, Red = N)". Usually this assumes user manually handles it or it's logic.
        // Wait, "Step A... Step F...". CSV Mapping table in prompt:
        // A -> Cols 2,3,4. B -> Cols 8,9,10. D -> Col 12.
        // It doesn't map 'Calls Back' to a column, just visual Header Color.
        // Original code mapped it to near end. 
        // Let's stick to the prompt's explicit mapping.

        content = TraceTool.history.map(h => {
          const status = h.status + (h.callsBack === 'N' ? '!' : '');
          return `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${status},,`;
        }).join('\n');
      }

      if (content) textArea.value = content;

      overlay.style.display = 'flex';
      // overlay.querySelector('.notepad-header span').textContent = 'Notepad';
    }

    function closeNotepad() {
      overlay.style.display = 'none';
      focus();
    }

    // Make global for onclick
    window.closeNotepad = closeNotepad;

    // --- EVENT LOOP ---
    const focus = () => ghost.focus();
    window.addEventListener('click', focus);

    window.addEventListener('keydown', (e) => {
      if (overlay.style.display === 'flex') return; // Typing in notepad handled natively
      focus();

      if (e.key === 'Enter') {
        const rawCmd = inputBuffer.trim();
        const cmd = rawCmd.toUpperCase();

        // Push to History
        if (rawCmd) {
          commandHistory.push(rawCmd);
          historyIndex = -1;
          tempInputBuffer = '';
        }

        // Global Commands
        if (cmd === 'QUIT' || cmd === 'EXIT') {
          inputBuffer = '';
          switchState(STATE_MENU);
          return;
        }
        if (cmd === 'CLEAR' || cmd === 'CLS') {
          inputBuffer = '';
          clearTerminal();
          refreshUI(); // Re-render prompt
          return;
        }
        if (cmd === 'HELP' || cmd === '?') {
          inputBuffer = '';
          showHelp();
          // We don't return here because we want to stay in current state, just showed help.
          // Actually showHelp appends lines. We should probably re-render prompt.
          refreshUI();
          return;
        }
        if (cmd === 'EXPORT' || cmd === 'TEXT' || cmd === 'CSV') {
          inputBuffer = '';
          openNotepad();
          if (currentState === STATE_MENU) MenuTool.render();
          if (currentState === STATE_TRACE) TraceTool.render();
          return;
        }

        if (cmd === 'PLOT' || cmd === 'PLOTTER') {
          inputBuffer = '';
          Plotter.show();
          return;
        }

        if (cmd === 'SAVE') {
          commitInput('SAVE');
          inputBuffer = '';
          saveCSV();
          refreshUI();
          return;
        }

        if (cmd === 'LOAD') {
          commitInput('LOAD');
          inputBuffer = '';
          fileInput.click();
          // We don't refreshUI here immediately because the file dialog blocks, 
          // and we want to wait for file selection or cancel.
          // IF user cancels, we might need a way to restore prompt?
          // For now, let's at least refreshUI so the prompt returns if they cancel.
          refreshUI();
          return;
        }

        // Route to Tool
        inputBuffer = '';
        if (currentState === STATE_MENU) {
          MenuTool.handleInput(cmd);
        } else if (currentState === STATE_TRACE) {
          TraceTool.handleInput(cmd);
        }

        refreshUI();

      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (currentState === STATE_TRACE) {
          TraceTool.undo();
        } else {
          navigateHistory(-1);
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        // Down behavior undefined so left as history or no-op
        if (currentState === STATE_MENU) navigateHistory(1);
      } else if (e.key === 'Backspace') {
        inputBuffer = inputBuffer.slice(0, -1);
        refreshUI();
      } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        inputBuffer += e.key.toUpperCase();
        refreshUI();
      }
    });

    function refreshUI() {
      if (currentState === STATE_MENU) MenuTool.render();
      if (currentState === STATE_TRACE) TraceTool.render();
    }

    // --- NOTEPAD BUTTONS ---
    btnCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(textArea.value);
        // Visual feedback?
        const originalText = btnCopy.textContent;
        btnCopy.textContent = 'COPIED!';
        setTimeout(() => btnCopy.textContent = originalText, 1000);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    btnPaste.addEventListener('click', async () => {
      try {
        let text = await navigator.clipboard.readText();
        // Heuristic: Auto-format collapsed "Space WIR," into Newlines
        text = text.replace(/(\s)WIR,/g, '\nWIR,');

        // Overwrite usage
        textArea.value = text;
        textArea.focus();
      } catch (err) {
        console.error('Paste failed', err);
      }
    });

    // --- PLOTTER EVENTS ---
    btnPlotCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(plotterContent.innerText);
        const originalText = btnPlotCopy.textContent;
        btnPlotCopy.textContent = 'COPIED!';
        setTimeout(() => btnPlotCopy.textContent = originalText, 1000);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    btnPlotPrint.addEventListener('click', () => {
      const printWindow = window.open('', '', 'width=800,height=600');
      printWindow.document.write('<html><head><title>Wiring Diagram</title>');
      printWindow.document.write('<style>body{font-family:Consolas,monospace;white-space:pre;font-size:12px;}</style>');
      printWindow.document.write('</head><body>');
      printWindow.document.write(plotterContent.innerHTML); // Preserves colors? Colors need classes.
      // We need to inject the styles too if we want colors. 
      // User asked for "clean .txt". Colors might consume ink. 
      // If clean .txt means "black and white", I strip tags. 
      // But usually "print" implies WYSIWYG. 
      // Let's print clean TEXT (no colors) as "clean .txt" implies plainness.
      // Actually, keeping structure is key. 
      // Let's enable colors but keep it minimal.
      // Re-injecting simple styles.
      printWindow.document.write('<style>.ok{color:black}.warn{color:black}.bad{color:black}.muted{color:gray}</style>');
      // Wait, user might want color. "Clean .txt" implies structure. 
      // Let's strip the HTML tags for TRUE text print? 
      // No, then we lose the bolding/dimming useful for readability.
      // I will provide a black-and-white cleaned version.
      printWindow.document.write('</body></html>');
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
      printWindow.close();
    });

    // --- FILE OPERATIONS ---
    function saveCSV() {
      let csv = '';
      if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
        // Generate CSV from history if active trace exists
        csv = TraceTool.history.map(h => {
          const status = h.status + (h.callsBack === 'N' ? '!' : '');
          return `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${status},,`;
        }).join('\n');
      } else {
        // Otherwise use Notepad content
        csv = textArea.value;
      }

      if (!csv) {
        appendLine('<span class="warn">NO DATA TO SAVE</span>');
        return;
      }

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'TC-Export.csv';
      a.click();
      URL.revokeObjectURL(url);
      appendLine('<span class="ok">FILE SAVED: TC-Export.csv</span>');
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const content = event.target.result;
        // Auto-fix for space WIR if needed, similar to paste
        const fixedContent = content.replace(/(\s)WIR,/g, '\nWIR,');

        textArea.value = fixedContent;
        appendLine(`<span class="ok">FILE LOADED: ${file.name}</span>`);

        // Clear input so same file can be loaded again if needed
        fileInput.value = '';

        refreshUI(); // Ensure fresh prompt appears
      };
      reader.readAsText(file);
    });

    // --- INIT ---
    switchState(STATE_MENU);
  </script>
</body>

</html>