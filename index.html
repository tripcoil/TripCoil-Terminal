<!doctype html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>TripCoil Terminal V1.1</title>
  <style>
    :root {
      --bg: #05080a;
      --fg: #b8ffe1;
      --dim: #67d7b3;
      --accent: #19ff9a;
      --warn: #ffd36a;
      --shadow: rgba(25, 255, 154, .20);
      --scan: rgba(25, 255, 154, .06);
      --border: rgba(25, 255, 154, .20);
    }

    html,
    body {
      height: 100%;
      margin: 0;
      background: radial-gradient(1200px 700px at 30% 20%, #071115 0%, var(--bg) 55%, #030506 100%);
      overflow: hidden;
    }

    body {
      display: flex;
      align-items: center;
      justify-content: center;
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, monospace;
    }

    .frame {
      width: min(980px, 92vw);
      height: min(620px, 86vh);
      border-radius: 18px;
      border: 1px solid var(--border);
      box-shadow: 0 0 40px var(--shadow);
      overflow: hidden;
      position: relative;
      background: #000;
    }

    .titlebar {
      height: 44px;
      display: flex;
      align-items: center;
      justify-content: center;
      /* Center header title */
      padding: 0 14px;
      background: rgba(0, 0, 0, 0.5);
      border-bottom: 1px solid var(--border);
    }

    .title {
      color: #FF453A;
      /* High-visibility Signal Red */
      text-shadow: 0 0 8px rgba(255, 69, 58, 0.7);
      /* Subtle glow */
      font-size: 16px;
      font-weight: bold;
      font-family: inherit;
      opacity: 1;
      letter-spacing: 1px;
      /* Improves legibility */
    }

    .header.green {
      color: #28c840;
      font-weight: bold;
    }

    .header.red {
      color: #ff5f57;
      font-weight: bold;
    }

    .terminal {
      position: absolute;
      inset: 44px 0 0 0;
      padding: 20px;
      color: var(--fg);
      overflow-y: auto;
    }

    .prompt {
      color: var(--accent);
    }

    .input-row {
      display: flex;
      align-items: flex-end;
      /* Align input with bottom of text */
      flex-wrap: wrap;
      /* Allow wrapping for multi-line prompts */
      /* Fix for baseline jitter */
      gap: 10px;
      padding: 2px 0;
    }

    .input-row.multi-line {
      display: block;
    }

    .input-group {
      display: inline-flex;
      align-items: center;
      /* Ensure caret and text align vertically */
      gap: 0;
      min-height: 1.2em;
      vertical-align: bottom;
      /* Ensure height creates stability even if empty */
    }

    .caret {
      display: inline-block;
      width: 9px;
      height: 1.1em;
      background: var(--accent);
      animation: blink 1s infinite;
      vertical-align: middle;
    }

    @keyframes blink {
      50% {
        opacity: 0;
      }
    }

    /* Fix for Safari/Brave focus */
    .ghost-input {
      position: fixed;
      top: 0;
      left: 0;
      width: 1px;
      height: 1px;
      opacity: 0;
      border: none;
      pointer-events: none;
      z-index: -1;
    }

    .notepad-overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: #fff;
      z-index: 100;
      flex-direction: column;
      color: #000;
    }

    .notepad-header {
      height: 32px;
      background: #eee;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-family: sans-serif;
      font-size: 12px;
    }

    .notepad-close {
      margin-left: auto;
      width: 45px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
    }

    .notepad-close:hover {
      background: #e81123;
      color: #fff;
    }

    .notepad-content {
      flex: 1;
      padding: 15px;
      font-family: 'Consolas', monospace;
      font-size: 14px;
      border: none;
      outline: none;
      resize: none;
    }

    .edit-menu {
      display: flex;
      gap: 8px;
      margin-left: 15px;
    }

    .cmd-btn {
      background: #e0e0e0;
      border: 1px solid #b0b0b0;
      padding: 2px 8px;
      font-size: 11px;
      cursor: pointer;
      font-family: sans-serif;
      color: #333;
    }

    .cmd-btn:hover {
      background: #d0d0d0;
      border-color: #999;
    }

    .cmd-btn:active {
      background: #ccc;
    }

    /* Mobile Controls */
    .mobile-controls {
      position: fixed;
      bottom: 20px;
      right: 20px;
      display: flex;
      flex-direction: column;
      gap: 10px;
      z-index: 50;
      opacity: 0.6;
    }

    .mobile-controls:hover {
      opacity: 1;
    }

    .history-btn {
      width: 40px;
      height: 40px;
      background: rgba(255, 255, 255, 0.1);
      border: 1px solid var(--accent);
      color: var(--accent);
      font-size: 20px;
      border-radius: 50%;
      cursor: pointer;
      display: flex;
      align-items: center;
      justify-content: center;
      user-select: none;
      backdrop-filter: blur(2px);
    }

    .history-btn:active {
      background: var(--accent);
      color: #000;
    }

    /* Plotter Styles */
    .plotter-overlay {
      display: none;
      position: absolute;
      inset: 0;
      background: #fff;
      z-index: 100;
      flex-direction: column;
      color: #000;
    }

    .plotter-header {
      height: 32px;
      background: #eee;
      border-bottom: 1px solid #ccc;
      display: flex;
      align-items: center;
      padding-left: 10px;
      font-family: sans-serif;
      font-size: 12px;
    }

    .plotter-content {
      flex: 1;
      padding: 15px;
      font-family: 'Consolas', monospace;
      font-size: 12px;
      border: none;
      outline: none;
      overflow: auto;
      white-space: pre;
      margin: 0;
    }

    /* Plotter Colors */
    .ok {
      color: #28a745;
    }

    .warn {
      color: #fd7e14;
    }

    .bad {
      color: #dc3545;
    }

    .muted {
      color: #6c757d;
    }
  </style>
</head>

<body>
  <div class="frame">
    <div class="titlebar">
      <div class="title" id="main-header">TRIPCOIL TERMINAL V1.1</div>
    </div>
    <div class="terminal" id="terminal">
      <div id="content"></div>
      <input class="ghost-input" id="ghost" type="text" autocomplete="off" spellcheck="false" inputmode="email"
        autofocus>
    </div>

    <div class="notepad-overlay" id="notepad-overlay">
      <div class="notepad-header" style="position: relative; justify-content: space-between;">
        <!-- Left: Icon + Buttons -->
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 18px; margin-right: 5px;">üìù</span>
          <div class="edit-menu" style="margin-left: 0;">
            <button class="cmd-btn" id="btn-copy">COPY</button>
            <button class="cmd-btn" id="btn-paste">PASTE</button>
          </div>
        </div>

        <!-- Center: Title -->
        <div
          style="position: absolute; left: 50%; transform: translateX(-50%); font-weight: bold; font-size: 14px; text-transform: uppercase; text-shadow: 1px 1px 0 #fff, 2px 2px 2px rgba(0,0,0,0.2);">
          DATA INTERFACE
        </div>

        <!-- Right: Close -->
        <div class="notepad-close" onclick="closeNotepad()" style="margin-left: 0;">‚úï</div>
      </div>
      <textarea class="notepad-content" id="notepad-textarea"></textarea>
    </div>

    <div class="plotter-overlay" id="plotter-overlay">
      <div class="plotter-header" style="position: relative; justify-content: space-between;">
        <!-- Left: Icon + Buttons -->
        <div style="display: flex; align-items: center; gap: 10px;">
          <span style="font-size: 18px; margin-right: 5px;">üìù</span>
          <div class="edit-menu" style="margin-left: 0;">
            <button class="cmd-btn" id="btn-plot-copy">COPY</button>
            <button class="cmd-btn" id="btn-plot-print">PRINT</button>
          </div>
        </div>

        <!-- Center: Title -->
        <div
          style="position: absolute; left: 50%; transform: translateX(-50%); font-weight: bold; font-size: 14px; text-transform: uppercase; text-shadow: 1px 1px 0 #fff, 2px 2px 2px rgba(0,0,0,0.2);">
          PLOTTER
        </div>

        <!-- Right: Close -->
        <div class="notepad-close" onclick="closePlotter()" style="margin-left: 0;">‚úï</div>
      </div>
      <pre class="plotter-content" id="plotter-content"></pre>
    </div>

    <div class="mobile-controls">
      <div class="history-btn" id="btn-up">‚àß</div>
      <div class="history-btn" id="btn-down">‚à®</div>
    </div>

    <!-- Hidden File Input for LOAD command -->
    <input type="file" id="file-input" accept=".csv" style="display:none">
  </div>

  <script>
    const content = document.getElementById('content');
    const terminal = document.getElementById('terminal');
    const ghost = document.getElementById('ghost');
    const overlay = document.getElementById('notepad-overlay');
    const textArea = document.getElementById('notepad-textarea');
    const btnCopy = document.getElementById('btn-copy');
    const btnPaste = document.getElementById('btn-paste');
    const btnUp = document.getElementById('btn-up');
    const btnDown = document.getElementById('btn-down');

    const mainHeader = document.getElementById('main-header'); // Cached ref

    // Plotter Refs
    const plotterOverlay = document.getElementById('plotter-overlay');
    const plotterContent = document.getElementById('plotter-content');
    const btnPlotCopy = document.getElementById('btn-plot-copy');
    const btnPlotPrint = document.getElementById('btn-plot-print');

    // Load Ref
    const fileInput = document.getElementById('file-input');

    // --- STATE MANAGEMENT ---
    const STATE_MENU = 'MENU';
    const STATE_TRACE = 'TRACE';
    let currentState = STATE_MENU;

    // --- SHARED UTILS ---
    let inputBuffer = '';

    // History
    const commandHistory = [];
    let historyIndex = -1;
    let tempInputBuffer = '';

    function setHeader(text, type = 'normal') {
      mainHeader.textContent = text;
      mainHeader.className = 'title'; // Reset
      if (type === 'green') mainHeader.className += ' header green';
      if (type === 'red') mainHeader.className += ' header red';
    }

    function clearTerminal() {
      content.innerHTML = '';
      inputBuffer = '';
    }

    function appendLine(html) {
      const div = document.createElement('div');
      div.className = 'term-line'; // Class for easier removal
      div.innerHTML = html;
      content.appendChild(div);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function removeLastLine() {
      const lines = content.getElementsByClassName('term-line');
      if (lines.length > 0) {
        lines[lines.length - 1].remove();
      }
    }

    function renderInput(prompt, preContent = '') {
      let active = document.getElementById('active-row');
      if (active) active.remove();

      const container = document.createElement('div');
      container.id = 'active-row';

      // If we have pre-content (like the Queue), add it as a block above
      if (preContent) {
        const preDiv = document.createElement('div');
        preDiv.className = 'input-pre-content';
        preDiv.innerHTML = preContent;
        container.appendChild(preDiv);
      }

      const row = document.createElement('div');
      row.className = 'input-row';
      // No longer need multi-line class logic if we separate content

      row.innerHTML = `<span class="prompt">${prompt}</span> <span class="input-group"><span>${inputBuffer}</span><span class="caret"></span></span>`;
      container.appendChild(row);

      content.appendChild(container);
      terminal.scrollTop = terminal.scrollHeight;
    }

    function commitInput(cmd) {
      const active = document.getElementById('active-row');
      const promptText = active ? active.querySelector('.prompt').innerHTML : '>';
      // Instead of removing, we transform it into a static line (remove ID, remove caret)
      if (active) {
        active.removeAttribute('id');
        const caret = active.querySelector('.caret');
        if (caret) caret.remove();
        // Or simply replace with static text to ensure cleanliness
        // But matching exact plan:
        // appendLine(`${promptText} <span>${cmd}</span>`);
        // The plan said: "remove active, appendLine".
        active.remove(); // Remove blinking one
        appendLine(`${promptText} <span>${cmd}</span>`); // Add static one
      }
    }

    // --- HISTORY LOGIC ---
    function navigateHistory(direction) {
      if (commandHistory.length === 0) return;

      if (historyIndex === -1 && direction === -1) {
        tempInputBuffer = inputBuffer;
        historyIndex = commandHistory.length - 1;
      } else {
        historyIndex += direction;
      }

      if (historyIndex < -1) historyIndex = -1;
      if (historyIndex >= commandHistory.length) historyIndex = commandHistory.length - 1;

      if (historyIndex === -1) {
        inputBuffer = tempInputBuffer;
      } else {
        inputBuffer = commandHistory[historyIndex];
      }
      refreshUI();
    }

    // --- MOBILE BUTTONS ---
    if (btnUp && btnDown) {
      btnUp.addEventListener('click', (e) => {
        e.stopPropagation();
        // Undo Action
        if (currentState === STATE_TRACE) {
          TraceTool.undo();
        } else {
          navigateHistory(-1); // Menu context
        }
        focus();
      });
      btnDown.addEventListener('click', (e) => {
        e.stopPropagation();
        if (currentState === STATE_MENU) navigateHistory(1);
        focus();
      });
    }

    // --- MAIN MENU PROGRAM ---
    const MenuTool = {
      init() {
        clearTerminal();
        setHeader('TRIPCOIL TERMINAL V1.1');
        // Visual Layout
        appendLine('----------------------------------------');
        appendLine('<span class="prompt">AVAILABLE MODULES:</span>');
        appendLine('&nbsp;&nbsp;1. TRACE TOOL (Active Verification)');
        appendLine('<br>');
        appendLine('<span class="prompt">AVAILABLE UTILITIES:</span>');
        appendLine('&nbsp;&nbsp;2. PLOTTER (Generate Schematics)');
        appendLine('&nbsp;&nbsp;3. DATA INTERFACE (Import/Export CSV)');
        appendLine('&nbsp;&nbsp;4. SETTINGS');
        appendLine('<br>');
        appendLine('<span class="prompt">SYSTEM COMMANDS:</span>');
        appendLine('&nbsp;&nbsp;HELP, QUIT, CLEAR');
        appendLine('----------------------------------------');
        inputBuffer = '';
        this.render();
      },
      handleInput(val) {
        if (val === '1' || val === 'TRACE' || val === 'TRACE TOOL') {
          switchState(STATE_TRACE);
        } else if (val === '2' || val === 'PLOTTER' || val === 'PLOT') {
          Plotter.show();
        } else if (val === '3' || val === 'DATA' || val === 'CSV' || val === 'EXPORT') {
          openNotepad();
        } else if (val === '4' || val === 'SETTINGS' || val === 'SET') {
          appendLine(`<span class="warn">SETTINGS MODULE NOT LOADED</span>`);
        } else {
          appendLine(`<span style="color:var(--warn)">INVALID SELECTION</span>`);
        }
      },
      render() {
        renderInput('SELECT MODULE OR UTILITY>');
      }
    };


    // --- PLOTTER TOOL ---
    const Plotter = {
      show() {
        let csv = '';
        if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
          csv = TraceTool.history.map(h => `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${h.status}${h.callsBack === 'N' ? '!' : ''},,`).join('\n');
        } else if (textArea.value.includes('WIR,')) {
          // Fallback: try to read from notepad if it has data
          csv = textArea.value;
        }

        if (!csv) {
          plotterContent.innerHTML = '<span class="muted">No data to plot. Start a trace or export first.</span>';
          plotterOverlay.style.display = 'flex';
          return;
        }

        try {
          const rows = this.parse(csv);
          const graph = this.buildGraph(rows);
          const html = this.renderTree(graph);
          plotterContent.innerHTML = html;
        } catch (e) {
          console.error(e);
          plotterContent.innerHTML = `<span class="bad">Error rendering plot: ${e.message}</span>`;
        }
        plotterOverlay.style.display = 'flex';
      },
      close() {
        plotterOverlay.style.display = 'none';
        focus();
      },
      parse(csv) {
        // Auto-fix missing newlines for WIR rows (robustness for bad copy-paste)
        const cleanCsv = csv.replace(/(\s)WIR,/g, '\nWIR,');
        return cleanCsv.split('\n').map(l => l.trim().split(',')).filter(r => r[0] === 'WIR').map(c => ({
          from: { p: c[1], d: c[2], t: c[3] }, to: { p: c[7], d: c[8], t: c[9] }, status: c[11]
        }));
      },
      buildGraph(rows) {
        const nodes = new Map();
        const visited = new Set();
        const k = (p, d, t) => `${p}|${d}|${t}`;
        rows.forEach(r => {
          const fk = k(r.from.p, r.from.d, r.from.t);
          const tk = k(r.to.p, r.to.d, r.to.t);
          if (!nodes.has(fk)) nodes.set(fk, { l: `${r.from.p}/${r.from.d}/${r.from.t}`, conns: [] });

          let s = 'muted';
          if (r.status === 'C' || r.status === '.') s = 'ok';
          else if (r.status && r.status.includes('!')) s = 'bad';
          else if (r.status && r.status.endsWith('?')) s = 'warn';

          nodes.get(fk).conns.push({ k: tk, l: `${r.to.p}/${r.to.d}/${r.to.t}`, s: s });
          visited.add(tk);
        });
        nodes.forEach(n => n.conns.sort((a, b) => a.l.localeCompare(b.l)));
        const roots = [...nodes.keys()].filter(k => !visited.has(k));
        return { nodes, roots };
      },
      renderTree({ nodes, roots }) {
        let out = '';
        const draw = (key, pfx, isRoot) => {
          const n = nodes.get(key);
          const lbl = n ? n.l : key.split('|').join('/');
          let h = '';

          if (isRoot) h += `${lbl}\n`;
          if (!n) return h;

          n.conns.forEach((c, i) => {
            const last = i === n.conns.length - 1;
            h += `${pfx}${last ? '‚îî‚îÄ‚îÄ ' : '‚îú‚îÄ‚îÄ '}<span class="${c.s}">${c.l}</span>\n`;
            if (nodes.has(c.k)) {
              h += draw(c.k, pfx + (last ? '    ' : '‚îÇ   '), false);
            }
          });
          return h;
        };
        roots.forEach(r => out += draw(r, '', true) + '\n');
        return out || 'No roots found.';
      }
    };
    window.closePlotter = () => Plotter.close();

    // --- TRACE TOOL PROGRAM (LOOP-BACK & BRANCH) ---
    const TraceTool = {
      // State
      discoveryStack: [], // Renamed from stack
      rows: [], // LIVE CSV DATA
      history: [],
      inputs: {},
      phase: 'SEED',
      currentFrom: null,
      lastVerified: null, // New State for "Verified" header
      undoStack: [], // Snapshots

      // Constants
      PHASE: {
        SEED_PANEL: 'SEED_PANEL',
        SEED_DEVICE: 'SEED_DEVICE',
        SEED_TERMINAL: 'SEED_TERMINAL',

        DEST_PANEL: 'DEST_PANEL',
        DEST_DEVICE: 'DEST_DEVICE',
        DEST_TERMINAL: 'DEST_TERMINAL',

        CALLBACK: 'CALLBACK',
        DENSITY: 'DENSITY',

        COMPLETE: 'COMPLETE'
      },

      init() {
        clearTerminal();
        setHeader(''); // Initially blank as requested
        this.discoveryStack = [];
        this.rows = this.parseRows(textArea.value); // Load from Global Text Area
        this.history = [];
        this.undoStack = [];
        this.inputs = {};
        this.currentFrom = null;
        this.lastVerified = null;
        this.phase = this.PHASE.SEED_PANEL;
        inputBuffer = '';
        this.render();
      },

      saveState(processedInput) {
        // Serialize current state
        const snapshot = {
          phase: this.phase,
          inputs: JSON.parse(JSON.stringify(this.inputs)),
          discoveryStack: JSON.parse(JSON.stringify(this.discoveryStack)),
          history: JSON.parse(JSON.stringify(this.history)),
          currentFrom: this.currentFrom ? JSON.parse(JSON.stringify(this.currentFrom)) : null,
          lastVerified: this.lastVerified ? JSON.parse(JSON.stringify(this.lastVerified)) : null,
          lastInput: processedInput
        };
        this.undoStack.push(snapshot);
      },

      undo() {
        if (this.undoStack.length === 0) return;

        const snap = this.undoStack.pop();

        // Restore
        this.phase = snap.phase;
        this.inputs = snap.inputs;
        this.discoveryStack = snap.discoveryStack;
        this.history = snap.history;
        this.history = snap.history;
        this.currentFrom = snap.currentFrom;
        this.lastVerified = snap.lastVerified; // Restore verified state

        // Visual: Remove last line
        removeLastLine();

        // Input: Restore what they typed
        inputBuffer = snap.lastInput;

        this.render();
      },

      handleInput(val) {
        this.saveState(val); // Undo point -> Current State + The Input being processed

        const P = this.PHASE;

        switch (this.phase) {
          // --- SEED PHASE ---
          case P.SEED_PANEL:
            this.inputs.p = val;
            appendLine(`<span class="prompt">FROM PANEL:</span> <span>${val}</span>`);
            setHeader(`üìç    ${this.inputs.p}    üìç`);
            this.phase = P.SEED_DEVICE;
            break;

          case P.SEED_DEVICE:
            this.inputs.d = val;
            appendLine(`<span class="prompt">FROM DEVICE:</span> <span>${val}</span>`);
            setHeader(`üìç    ${this.inputs.p} ${this.inputs.d}    üìç`);
            this.phase = P.SEED_TERMINAL;
            break;

          case P.SEED_TERMINAL:
            this.inputs.t = val;
            appendLine(`<span class="prompt">FROM TERMINAL:</span> <span>${val}</span>`);
            // Seed established. Initialize currentFrom.
            // Update Header to full Seed
            setHeader(`üìç    ${this.inputs.p} ${this.inputs.d} ${this.inputs.t}    üìç`);

            this.currentFrom = { p: this.inputs.p, d: this.inputs.d, t: this.inputs.t, count: 0 };

            // Note: startDestinationPhase() now handles clearing the screen
            this.startDestinationPhase();
            break;

          // --- DESTINATION PHASE ---
          case P.DEST_PANEL:
            this.inputs.toP = val;
            appendLine(`<span class="prompt">TO PANEL:</span> <span>${val}</span>`);
            this.phase = P.DEST_DEVICE;
            break;

          case P.DEST_DEVICE:
            this.inputs.toD = val;
            appendLine(`<span class="prompt">TO DEVICE:</span> <span>${val}</span>`);
            this.phase = P.DEST_TERMINAL;
            break;

          case P.DEST_TERMINAL:
            this.inputs.toT = val;
            appendLine(`<span class="prompt">TO TERMINAL:</span> <span>${val}</span>`);

            // Immediate Transition: Update Header & Clear Screen
            setHeader(`üìç    ${this.inputs.toP} ${this.inputs.toD} ${this.inputs.toT}    üìç`);
            clearTerminal();

            this.phase = P.CALLBACK;
            break;

          // --- CALLBACK PHASE ---
          case P.CALLBACK:
            const norm = val.toUpperCase().trim();
            const isYes = norm.startsWith('Y');
            this.inputs.callsBack = isYes ? 'Y' : 'N';

            appendLine(`<span class="prompt">FOUND WIRE ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}?</span> <span>${this.inputs.callsBack}</span>`);

            // Update Header Color (Temporary for Callback Check)
            // User requested header remains static with FROM loc until TO TERM entered.
            // But this is the check step. Maybe we keep the static header or show the check?
            // Header updated in DEST_TERMINAL now.
            // setHeader(`üìç    ${this.inputs.toP} ${this.inputs.toD} ${this.inputs.toT}    üìç`);

            clearTerminal(); // Clear before asking Density
            this.phase = P.DENSITY;
            break;

          // --- DENSITY PHASE ---
          case P.DENSITY:
            const count = parseInt(val);
            if (isNaN(count)) {
              appendLine(`<span style="color:var(--warn)">INVALID NUMBER</span>`);
              this.render();
              return;
            }
            appendLine(`<span class="prompt">BESIDES ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}, HOW MANY WIRES ON ${this.inputs.toP}/${this.inputs.toD}/${this.inputs.toT}?</span> <span>${val}</span>`);
            this.processJump(count);
            break;
        }

        this.render();
      },

      startDestinationPhase() {
        clearTerminal(); // Clear history when starting a new leg
        this.inputs.toP = '';
        this.inputs.toD = '';
        this.inputs.toT = ''; // Clear destination buffer
        this.inputs.callsBack = '';
        this.phase = this.PHASE.DEST_PANEL;
      },

      markHistoryComplete(term) {
        // Update any history records where this terminal was the destination
        this.history.forEach(h => {
          if (h.to.p === term.p && h.to.d === term.d && h.to.t === term.t) {
            h.status = 'C';
          }
        });
      },

      processJump(toCount) {
        // 1. Find Matching Row in CSV Data (Bidirectional & Case-Insensitive)
        // Ensure inputs are clean/upper for comparison
        const cp = this.currentFrom.p.toUpperCase();
        const cd = this.currentFrom.d.toUpperCase();
        const ct = this.currentFrom.t.toUpperCase();
        const tp = this.inputs.toP.toUpperCase();
        const td = this.inputs.toD.toUpperCase();
        const tt = this.inputs.toT.toUpperCase();

        const match = this.rows.find(r => {
          if (r.type !== 'WIR') return false;
          // Fallback to empty string if undefined (though parseRows handles it)
          const rp = (r.pan || '').toUpperCase();
          const rd = (r.dev || '').toUpperCase();
          const rt = (r.term || '').toUpperCase();
          const rtp = (r.to_pan || '').toUpperCase();
          const rtd = (r.to_dev || '').toUpperCase();
          const rtt = (r.to_term || '').toUpperCase();

          // Forward
          if (rp === cp && rd === cd && rt === ct && rtp === tp && rtd === td && rtt === tt) return true;
          // Reverse
          if (rp === tp && rd === td && rt === tt && rtp === cp && rtd === cd && rtt === ct) return true;

          return false;
        });

        let status = 'C';
        // 2. Update Status
        if (match) {
          match.status = 'C';
          // If callsBack logic needed?
          // "If ... confirms the 'Call-Back', immediately update... STATUS to 'C'"
          // Assuming 'C' implies callback verified or N/A.
          // If callsBack === 'N', traditionally we flagged it '!' or similar.
          // But 'C' counts as verified.
        } else {
          // Create NEW Row (User found wire not in CSV)
          this.rows.push({
            type: 'WIR',
            pan: this.currentFrom.p, dev: this.currentFrom.d, term: this.currentFrom.t,
            kind: '', elem: '', part: '',
            to_pan: this.inputs.toP, to_dev: this.inputs.toD, to_term: this.inputs.toT,
            cable: '', status: 'C', signal: '', remarks: 'FIELD_ADD'
          });
        }

        // --- LEGACY HISTORY PUSH (Keep for now or remove?) ---
        // Plan said: "Update Export Logic to use internal state"
        // So history is now secondary or redundant.
        // But the UI (TraceTool) might rely on history for something else?
        // `markHistoryComplete()` is now obsolete if we use `this.rows`.

        // 3. Update Discovery Stack (THE COUNTDOWN)
        // With Live CSV, do we still need discoveryStack?
        // "Refresh UI... TraceTool to move to the next item in the discoveryStack"
        // Yes, discoveryStack drives the *flow* (where we go next).
        // But the *density* logic in discoveryStack is now redundant?
        // User said: "Count number of rows... Use this count to populate the display."
        // So we don't need manual density input if data exists.
        // BUT logic for `processJump(count)` assumes manual density for new checks.
        // Let's keep stack for circle-back flow.

        // LEGACY STACK LOGIC (Keep for flow control)
        const stackIdx = this.discoveryStack.findIndex(n =>
          n.p === this.currentFrom.p && n.d === this.currentFrom.d && n.t === this.currentFrom.t
        );

        if (stackIdx !== -1) {
          // We still decrement to pop it from stack when "done"
          // Or should we check CSV status?
          // "Move to next item... or clear [PENDING] list"
          // If we decrement manually, we might de-sync from CSV.
          // Better: Check if *any* status includes '?' for this terminal?
          // But for now, let's keep the manual decrement to close the loop.
          this.discoveryStack[stackIdx].count--;
          if (this.discoveryStack[stackIdx].count <= 0) {
            this.discoveryStack.splice(stackIdx, 1);
          }
        }

        // 4. Handle "To" Terminal Logic (Next Step)
        // Check if destination has pending wires in CSV?
        // If yes, push to stack automatically?
        // "Scaling: handles 100-line test runs effortlessly"
        // If I jump to T2, and T2 has 5 pending wires in CSV, I should probably auto-push T2 to stack.
        // Instead of asking "Density?".
        // LET'S IMPLEMENT THAT AUTO-DENSITY CHECK.

        let nextCount = toCount; // Default (if manual)

        // Check CSV for destination
        const destPending = this.rows.filter(r =>
          r.type === 'WIR' &&
          r.pan === this.inputs.toP &&
          r.dev === this.inputs.toD &&
          r.term === this.inputs.toT &&
          r.status !== 'C'
        );

        if (destPending.length > 0) {
          nextCount = destPending.length;
        }

        const toNode = {
          p: this.inputs.toP,
          d: this.inputs.toD,
          t: this.inputs.toT,
          count: nextCount,
          total: nextCount // Can be revised based on CSV total
        };

        const lastMove = {
          from: { p: this.currentFrom.p, d: this.currentFrom.d, t: this.currentFrom.t },
          to: { p: this.inputs.toP, d: this.inputs.toD, t: this.inputs.toT }
        };

        if (nextCount > 0) {
          // Push To Node to Discovery Stack
          this.discoveryStack.push(toNode);

          // Move forward
          this.currentFrom = toNode;
          setHeader(`üìç    ${this.currentFrom.p} ${this.currentFrom.d} ${this.currentFrom.t}    üìç`);
          this.startDestinationPhase(); // Clears this.inputs
        } else {
          // Dead End -> Circle Back
          this.circleBack();
        }

        // Set Last Verified
        this.lastVerified = lastMove;
      },

      circleBack() {
        if (this.discoveryStack.length > 0) {
          // Pull most recent from Active Discovery Stack
          const nextSrc = this.discoveryStack[this.discoveryStack.length - 1]; // Peek/Get
          this.currentFrom = nextSrc;

          // Update Header on Circle Back
          setHeader(`üìç    ${this.currentFrom.p} ${this.currentFrom.d} ${this.currentFrom.t}    üìç`);

          appendLine(`<div style="color:var(--accent)">‚Ü∫ CIRCLING BACK TO: ${nextSrc.p} / ${nextSrc.d} / ${nextSrc.t} (${nextSrc.count} LEFT)</div>`);

          this.startDestinationPhase();
        } else {
          // Session Complete
          this.phase = this.PHASE.COMPLETE;
          setHeader('SESSION COMPLETE', 'green');
          appendLine('<div style="color:var(--warn)">NO PENDING WIRES - TRACE COMPLETE</div>');
          appendLine('<div class="prompt">TYPE "EXPORT" TO SAVE CSV</div>');
        }
      },

      render() {
        let label = '';
        const P = this.PHASE;

        switch (this.phase) {
          case P.SEED_PANEL: label = 'FROM PANEL?'; break;
          case P.SEED_DEVICE: label = 'FROM DEVICE?'; break;
          case P.SEED_TERMINAL: label = 'FROM TERMINAL?'; break;

          case P.DEST_PANEL:
            // "Take out the blue text that says FROM: ..."
            label = 'TO PANEL:';
            break;
          case P.DEST_DEVICE: label = 'TO DEVICE?'; break;
          case P.DEST_TERMINAL: label = 'TO TERMINAL?'; break;

          case P.CALLBACK:
            label = `FOUND WIRE ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}? (Y/N)`;
            break;

          case P.DENSITY:
            label = `<i>EXCLUDING ${this.currentFrom.p}/${this.currentFrom.d}/${this.currentFrom.t}...</i><br>HOW MANY WIRES ON<br>${this.inputs.toP}/${this.inputs.toD}/${this.inputs.toT}?`;
            break;

          case P.COMPLETE: label = 'COMPLETE (TYPE QUIT)'; break;
        }

        // If we are showing "TO PANEL", prepend the Physical Queue
        if (this.phase === P.DEST_PANEL) {
          const queueHtml = this.renderQueue();
          if (queueHtml) {
            // Pass as preContent to renderInput
            renderInput(label, queueHtml);
            return; // Initial render done
          }
        }

        if (label) renderInput(label);
      },

      parseRows(csvText) {
        if (!csvText) return [];
        // Simple CSV Parser (assuming standard 14-col format)
        // Header: ROW_TYPE, PANEL, DEVICE_TAG, TERMINAL, TERM_KIND, ELEM_ID, DEVICE_PART, TO_PANEL, TO_DEVICE, TO_TERMINAL, CABLE_ID, STATUS, SIGNAL_ID, REMARKS
        return csvText.split('\n')
          .map(line => line.trim())
          .filter(line => line && !line.startsWith('#') && !line.startsWith('ROW_TYPE'))
          .map(line => {
            const cols = line.split(',').map(c => c.trim());
            // Mapping to Object for easier access
            return {
              raw: line, // Note: raw might have spaces, but object properties are clean
              type: cols[0],
              pan: cols[1], dev: cols[2], term: cols[3],
              kind: cols[4], elem: cols[5], part: cols[6],
              to_pan: cols[7], to_dev: cols[8], to_term: cols[9],
              cable: cols[10], status: cols[11], signal: cols[12], remarks: cols[13]
            };
          });
      },

      renderQueue() {
        let out = '';

        if (!this.currentFrom) return '';

        const cur = this.currentFrom;
        const cp = cur.p.toUpperCase();
        const cd = cur.d.toUpperCase();
        const ct = cur.t.toUpperCase();

        // 1. Find ALL wires connected to this terminal (Bidirectional)
        const relevantRows = this.rows.filter(r => {
          if (r.type !== 'WIR') return false;

          // Fallback to empty string for safety
          const rp = (r.pan || '').toUpperCase();
          const rd = (r.dev || '').toUpperCase();
          const rt = (r.term || '').toUpperCase();
          const rtp = (r.to_pan || '').toUpperCase();
          const rtd = (r.to_dev || '').toUpperCase();
          const rtt = (r.to_term || '').toUpperCase();

          // Connected if current node matches EITHER end
          const matchSource = (rp === cp && rd === cd && rt === ct);
          const matchDest = (rtp === cp && rtd === cd && rtt === ct);

          return matchSource || matchDest;
        });

        const verified = relevantRows.filter(r => r.status === 'C');
        const pending = relevantRows.filter(r => r.status !== 'C');

        // Helper to formatting the "Other End"
        const fmtOther = (r) => {
          const rp = (r.pan || '').toUpperCase();
          const rd = (r.dev || '').toUpperCase();
          const rt = (r.term || '').toUpperCase();
          // If current Node is Source, return Dest. Else return Source.
          if (rp === cp && rd === cd && rt === ct) {
            return `${r.to_pan} ${r.to_dev} ${r.to_term}`;
          } else {
            return `${r.pan} ${r.dev} ${r.term}`;
          }
        };

        // 2. Render Verified List
        verified.forEach(r => {
          // Using simple [ ‚úì ] format
          out += `<span class="ok">[ ‚úì ] VERIFIED: ${fmtOther(r)}</span><br>`;
        });

        // 3. Render Pending List
        pending.forEach((r, idx) => {
          // Using [ ? ] format for pending
          out += `<span class="muted">[ ? ] PENDING : ${fmtOther(r)}</span><br>`;
        });

        // 4. "Ghost" Wires (Manual Density > CSV Data)
        let ghostCount = 0;
        if (this.currentFrom.count !== undefined) {
          ghostCount = this.currentFrom.count - pending.length;
        }

        if (ghostCount > 0) {
          // Pending List Separator from Verified?
          // Actually, we just want to append these after real pending.

          // If we have verified but NO real pending, but YES ghosts, we need the separator.
          // Or if we have real pending, separation logic is already handled by output flow?
          // No, we haven't added the middle separator yet in this implementation.
        }

        // Let's redo the flow cleanly:
        // A. Verified
        // -- Separator if Verified and (Pending OR Ghosts) --
        // B. Pending (Real + Ghosts)

        const hasPending = (pending.length > 0 || ghostCount > 0);

        if (verified.length > 0 && hasPending) {
          out += '<span>----------------------------------------</span><br>';
        }

        // Render Real Pending (already in out var if we moved it?)
        // Wait, I appended to `out` above. Let's restart building `out` to be safe/clean order.

        // RESTART BUILD
        let finalOut = '';
        verified.forEach(r => {
          finalOut += `<span class="ok">[ ‚úì ] VERIFIED: ${fmtOther(r)}</span><br>`;
        });

        if (verified.length > 0 && hasPending) {
          // Separator removed as per user request
          finalOut += '<br>'; // Optional: Keep some spacing? User asked to get rid of lines. Let's just use BR for spacing.
        }

        pending.forEach((r, idx) => {
          finalOut += `<span class="muted">[ ? ] PENDING : ${fmtOther(r)}</span><br>`;
        });

        if (ghostCount > 0) {
          for (let i = 0; i < ghostCount; i++) {
            finalOut += `<span class="muted">[ ? ] PENDING : WIRE ${pending.length + i + 1} (UNIDENTIFIED)</span><br>`;
          }
        }

        // Final Separator before prompt removed
        // if (finalOut) {
        //   finalOut += '<span>----------------------------------------</span><br>';
        // }

        return finalOut;
      }


    };

    // --- GLOBAL HANDLERS ---

    function switchState(newState) {
      currentState = newState;
      if (newState === STATE_MENU) MenuTool.init();
      if (newState === STATE_TRACE) TraceTool.init();
    }

    function showHelp() {
      appendLine('<div style="color:var(--dim)">--- TERMINAL CHEATSHEET ---</div>');
      appendLine('<div><span class="prompt">NAVIGATION:</span> Up/Down Arrow for Command History</div>');
      appendLine('<div><span class="prompt">MOBILE:</span> Use virtual buttons (‚àß/‚à®) for history/undo</div>');
      appendLine('<div><span class="prompt">DATA:</span> TYPE "CSV" (or EXPORT) for Data Interface</div>');
      appendLine('<div><span class="prompt">PLOT:</span> TYPE "PLOT" (or PLOTTER) for Wiring Diagram</div>');
      appendLine('<div><span class="prompt">FILE:</span> SAVE (Download CSV), LOAD (Open CSV)</div>');
      appendLine('<div><span class="prompt">SYSTEM:</span> CLEAR, QUIT (or EXIT), HELP</div>');
      appendLine('<div style="color:var(--dim)">---------------------------</div>');
    }

    function openNotepad() {
      // Generate CSV from LIVE rows if available, else usage history (fallback)
      let content = '';

      if (currentState === STATE_TRACE && TraceTool.rows.length > 0) {
        // Use the LIVE state (which has updated 'C' statuses)
        // Reconstruct CSV from objects
        const header = "ROW_TYPE, PANEL, DEVICE_TAG, TERMINAL, TERM_KIND, ELEM_ID, DEVICE_PART, TO_PANEL, TO_DEVICE, TO_TERMINAL, CABLE_ID, STATUS, SIGNAL_ID, REMARKS";
        const rows = TraceTool.rows.map(r => {
          // Rebuild line
          // r.type, r.pan, r.dev, r.term, r.kind, r.elem, r.part, r.to_pan, r.to_dev, r.to_term, r.cable, r.status, r.signal, r.remarks
          return `${r.type},${r.pan},${r.dev},${r.term},${r.kind || ''},${r.elem || ''},${r.part || ''},${r.to_pan || ''},${r.to_dev || ''},${r.to_term || ''},${r.cable || ''},${r.status || ''},${r.signal || ''},${r.remarks || ''}`;
        });
        content = header + '\n' + rows.join('\n');
      } else if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
        // Fallback to legacy history if no rows loaded?
        content = TraceTool.history.map(h => {
          const status = h.status + (h.callsBack === 'N' ? '!' : '');
          return `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${status},,`;
        }).join('\n');
      }

      if (content) textArea.value = content;

      overlay.style.display = 'flex';
    }

    function closeNotepad() {
      overlay.style.display = 'none';
      focus();
    }

    // Make global for onclick
    window.closeNotepad = closeNotepad;

    // --- EVENT LOOP ---
    const focus = () => ghost.focus();
    window.addEventListener('click', focus);

    window.addEventListener('keydown', (e) => {
      if (overlay.style.display === 'flex') return; // Typing in notepad handled natively
      focus();

      if (e.key === 'Enter') {
        const rawCmd = inputBuffer.trim();
        const cmd = rawCmd.toUpperCase();

        // Push to History
        if (rawCmd) {
          commandHistory.push(rawCmd);
          historyIndex = -1;
          tempInputBuffer = '';
        }

        // Global Commands
        if (cmd === 'QUIT' || cmd === 'EXIT') {
          inputBuffer = '';
          switchState(STATE_MENU);
          return;
        }
        if (cmd === 'CLEAR' || cmd === 'CLS') {
          inputBuffer = '';
          clearTerminal();
          refreshUI(); // Re-render prompt
          return;
        }
        if (cmd === 'HELP' || cmd === '?') {
          inputBuffer = '';
          showHelp();
          // We don't return here because we want to stay in current state, just showed help.
          // Actually showHelp appends lines. We should probably re-render prompt.
          refreshUI();
          return;
        }
        if (cmd === 'EXPORT' || cmd === 'TEXT' || cmd === 'CSV') {
          inputBuffer = '';
          openNotepad();
          if (currentState === STATE_MENU) MenuTool.render();
          if (currentState === STATE_TRACE) TraceTool.render();
          return;
        }

        if (cmd === 'PLOT' || cmd === 'PLOTTER') {
          inputBuffer = '';
          Plotter.show();
          return;
        }

        if (cmd === 'SAVE') {
          commitInput('SAVE');
          inputBuffer = '';
          saveCSV();
          refreshUI();
          return;
        }

        if (cmd === 'LOAD') {
          commitInput('LOAD');
          inputBuffer = '';
          fileInput.click();
          // We don't refreshUI here immediately because the file dialog blocks, 
          // and we want to wait for file selection or cancel.
          // IF user cancels, we might need a way to restore prompt?
          // For now, let's at least refreshUI so the prompt returns if they cancel.
          refreshUI();
          return;
        }

        // Route to Tool
        inputBuffer = '';
        if (currentState === STATE_MENU) {
          MenuTool.handleInput(cmd);
        } else if (currentState === STATE_TRACE) {
          TraceTool.handleInput(cmd);
        }

        refreshUI();

      } else if (e.key === 'ArrowUp') {
        e.preventDefault();
        if (currentState === STATE_TRACE) {
          TraceTool.undo();
        } else {
          navigateHistory(-1);
        }
      } else if (e.key === 'ArrowDown') {
        e.preventDefault();
        // Down behavior undefined so left as history or no-op
        if (currentState === STATE_MENU) navigateHistory(1);
      } else if (e.key === 'Backspace') {
        inputBuffer = inputBuffer.slice(0, -1);
        refreshUI();
      } else if (e.key.length === 1 && !e.ctrlKey && !e.metaKey && !e.altKey) {
        inputBuffer += e.key.toUpperCase();
        refreshUI();
      }
    });

    function refreshUI() {
      if (currentState === STATE_MENU) MenuTool.render();
      if (currentState === STATE_TRACE) TraceTool.render();
    }

    // --- NOTEPAD BUTTONS ---
    btnCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(textArea.value);
        // Visual feedback?
        const originalText = btnCopy.textContent;
        btnCopy.textContent = 'COPIED!';
        setTimeout(() => btnCopy.textContent = originalText, 1000);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    btnPaste.addEventListener('click', async () => {
      try {
        let text = await navigator.clipboard.readText();
        // Heuristic: Auto-format collapsed "Space WIR," into Newlines
        text = text.replace(/(\s)WIR,/g, '\nWIR,');

        // Overwrite usage
        textArea.value = text;
        textArea.focus();
      } catch (err) {
        console.error('Paste failed', err);
      }
    });

    // --- PLOTTER EVENTS ---
    btnPlotCopy.addEventListener('click', async () => {
      try {
        await navigator.clipboard.writeText(plotterContent.innerText);
        const originalText = btnPlotCopy.textContent;
        btnPlotCopy.textContent = 'COPIED!';
        setTimeout(() => btnPlotCopy.textContent = originalText, 1000);
      } catch (err) {
        console.error('Copy failed', err);
      }
    });

    btnPlotPrint.addEventListener('click', () => {
      const printWindow = window.open('', '', 'width=800,height=600');
      printWindow.document.write('<html><head><title>Wiring Diagram</title>');
      printWindow.document.write('<style>body{font-family:Consolas,monospace;white-space:pre;font-size:12px;}</style>');
      printWindow.document.write('</head><body>');
      printWindow.document.write(plotterContent.innerHTML); // Preserves colors? Colors need classes.
      // We need to inject the styles too if we want colors. 
      // User asked for "clean .txt". Colors might consume ink. 
      // If clean .txt means "black and white", I strip tags. 
      // But usually "print" implies WYSIWYG. 
      // Let's print clean TEXT (no colors) as "clean .txt" implies plainness.
      // Actually, keeping structure is key. 
      // Let's enable colors but keep it minimal.
      // Re-injecting simple styles.
      printWindow.document.write('<style>.ok{color:black}.warn{color:black}.bad{color:black}.muted{color:gray}</style>');
      // Wait, user might want color. "Clean .txt" implies structure. 
      // Let's strip the HTML tags for TRUE text print? 
      // No, then we lose the bolding/dimming useful for readability.
      // I will provide a black-and-white cleaned version.
      printWindow.document.write('</body></html>');
      printWindow.document.close();
      printWindow.focus();
      printWindow.print();
      printWindow.close();
    });

    // --- FILE OPERATIONS ---
    function saveCSV() {
      let csv = '';
      if (currentState === STATE_TRACE && TraceTool.rows.length > 0) {
        // Export LIVE state
        const header = "ROW_TYPE, PANEL, DEVICE_TAG, TERMINAL, TERM_KIND, ELEM_ID, DEVICE_PART, TO_PANEL, TO_DEVICE, TO_TERMINAL, CABLE_ID, STATUS, SIGNAL_ID, REMARKS";
        const rows = TraceTool.rows.map(r => {
          return `${r.type},${r.pan},${r.dev},${r.term},${r.kind || ''},${r.elem || ''},${r.part || ''},${r.to_pan || ''},${r.to_dev || ''},${r.to_term || ''},${r.cable || ''},${r.status || ''},${r.signal || ''},${r.remarks || ''}`;
        });
        csv = header + '\n' + rows.join('\n');
      } else if (currentState === STATE_TRACE && TraceTool.history.length > 0) {
        // Generate CSV from history if active trace exists (Fallback)
        csv = TraceTool.history.map(h => {
          const status = h.status + (h.callsBack === 'N' ? '!' : '');
          return `WIR,${h.from.p},${h.from.d},${h.from.t},,,,${h.to.p},${h.to.d},${h.to.t},,${status},,`;
        }).join('\n');
      } else {
        // Otherwise use Notepad content
        csv = textArea.value;
      }

      if (!csv) {
        appendLine('<span class="warn">NO DATA TO SAVE</span>');
        return;
      }

      const blob = new Blob([csv], { type: 'text/csv' });
      const url = URL.createObjectURL(blob);
      const a = document.createElement('a');
      a.href = url;
      a.download = 'TC-Export.csv';
      a.click();
      URL.revokeObjectURL(url);
      appendLine('<span class="ok">FILE SAVED: TC-Export.csv</span>');
    }

    fileInput.addEventListener('change', (e) => {
      const file = e.target.files[0];
      if (!file) return;

      const reader = new FileReader();
      reader.onload = (event) => {
        const content = event.target.result;
        // Auto-fix for space WIR if needed, similar to paste
        const fixedContent = content.replace(/(\s)WIR,/g, '\nWIR,');

        textArea.value = fixedContent;
        appendLine(`<span class="ok">FILE LOADED: ${file.name}</span>`);

        // Clear input so same file can be loaded again if needed
        fileInput.value = '';

        refreshUI(); // Ensure fresh prompt appears
      };
      reader.readAsText(file);
    });

    // --- INIT ---
    switchState(STATE_MENU);
  </script>
</body>

</html>